<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fractale — buckets + 3 catégories uniques</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<link rel="preconnect" href="https://cdn.skypack.dev" crossorigin>
<link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js">
<style>
  :root {
    color-scheme: dark;
    /* Hauteur de header par défaut (corrigée au 1er frame) + écart unifié */
    --menu-h: 48px;
    --menu-gap: 16px;
  }
  html, body { height: 100%; }
  body {
    margin: 0; overflow: hidden;
    background-color: #0055ff;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  }

  /* Canvas */
  #webgl-canvas {
    position: fixed; inset: 0; display: block; z-index: 1;
    opacity: 0; transition: opacity .25s ease;
  }

  /* Header */
  #ui-header {
    position: fixed; top: 0; left: 0; right: 0; height: var(--menu-h);
    z-index: 4; pointer-events: none;
  }
  #header-inner {
    height: 100%; display: flex; align-items: center; justify-content: flex-end;
    padding: 0 var(--menu-gap); /* base */
    padding-right: calc(var(--menu-gap) * 2); /* marge verte x2 */
    box-sizing: border-box; pointer-events: none; position: relative;
  }
  #nav-links { display: flex; gap: calc(var(--menu-gap) * 2); align-items: center; white-space: nowrap; pointer-events: auto; } /* espace ABOUT-CONTACT x2 */
  .nav-btn {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
    font-size: 14px; color: #e5e5e5; letter-spacing: .02em; text-decoration: none;
  }
  .nav-btn:hover, .nav-btn:focus { outline: none; color: #f7ff58; }

  #logo-link { pointer-events: auto; display: inline-flex; align-items: center; justify-content: center;
    margin-left: calc(var(--menu-gap) * 2); /* marge orange = verte */
  }
  #logo-overlay {
    height: calc(var(--menu-h) * 0.5);
    max-height: 44px; /* évite le logo trop gros au chargement */
    aspect-ratio: auto; display: block; user-select: none;
  }

  /* Mobile header */
  #mobile-left, #mobile-right {
    display: none; pointer-events: auto; color: #e5e5e5;
    position: absolute; top: 50%; transform: translateY(-50%);
  }
  #mobile-left  { left: var(--menu-gap); }
  #mobile-right { right: var(--menu-gap); }
  .mobile-icon { display: block; width: 22px; height: 22px; }

  @media (max-width: 640px) {
    #header-inner { justify-content: center; }
    #nav-links { display: none; }
    #logo-link { margin-left: 0; } /* mobile: on annule le décalage */
    #mobile-left, #mobile-right { display: inline-flex; align-items: center; }
  }

  @media (prefers-reduced-motion: reduce) { #webgl-canvas { transition: none; } }
</style>
</head>
<body>

<header id="ui-header" aria-label="Top menu">
  <div id="header-inner">
    <!-- Mobile -->
    <a id="mobile-left" href="#about" aria-label="About / Info">
      <svg class="mobile-icon" viewBox="0 0 15 15" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
        <path d="M7.49991 0.876892C3.84222 0.876892 0.877075 3.84204 0.877075 7.49972C0.877075 11.1574 3.84222 14.1226 7.49991 14.1226C11.1576 14.1226 14.1227 11.1574 14.1227 7.49972C14.1227 3.84204 11.1576 0.876892 7.49991 0.876892ZM1.82707 7.49972C1.82707 4.36671 4.36689 1.82689 7.49991 1.82689C10.6329 1.82689 13.1727 4.36671 13.1727 7.49972C13.1727 10.6327 10.6329 13.1726 7.49991 13.1726C4.36689 13.1726 1.82707 10.6327 1.82707 7.49972ZM8.24992 4.49999C8.24992 4.9142 7.91413 5.24999 7.49992 5.24999C7.08571 5.24999 6.74992 4.9142 6.74992 4.49999C6.74992 4.08577 7.08571 3.74999 7.49992 3.74999C7.91413 3.74999 8.24992 4.08577 8.24992 4.49999ZM6.00003 5.99999H6.50003H7.50003C7.77618 5.99999 8.00003 6.22384 8.00003 6.49999V9.99999H8.50003H9.00003V11H8.50003H7.50003H6.50003H6.00003V9.99999H6.50003H7.00003V6.99999H6.50003H6.00003V5.99999Z" fill-rule="evenodd" clip-rule="evenodd"/>
      </svg>
    </a>

    <!-- Desktop/Tablette -->
    <nav id="nav-links" aria-label="Primary">
      <a class="nav-btn" href="#about">[ ABOUT ]</a>
      <a class="nav-btn" href="#contact">[ CONTACT ]</a>
    </nav>

    <!-- Logo -->
    <a id="logo-link" href="/" aria-label="Home">
      <img id="logo-overlay" src="https://i.postimg.cc/nz6hx67W/logo-sooxy-art.png" alt="Logo Sooxy Art" loading="eager" decoding="async" />
    </a>

    <!-- Mobile -->
    <a id="mobile-right" href="#contact" aria-label="Contact">
      <svg class="mobile-icon" viewBox="0 0 15 15" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
        <path d="M1 2C0.447715 2 0 2.44772 0 3V12C0 12.5523 0.447715 13 1 13H14C14.5523 13 15 12.5523 15 12V3C15 2.44772 14.5523 2 14 2H1ZM1 3L14 3V3.92494C13.9174 3.92486 13.8338 3.94751 13.7589 3.99505L7.5 7.96703L1.24112 3.99505C1.16621 3.94751 1.0826 3.92486 1 3.92494V3ZM1 4.90797V12H14V4.90797L7.74112 8.87995C7.59394 8.97335 7.40606 8.97335 7.25888 8.87995L1 4.90797Z" fill-rule="evenodd" clip-rule="evenodd"/>
      </svg>
    </a>
  </div>
</header>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
    "simplex-noise": "https://cdn.skypack.dev/simplex-noise@4.0.1"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { createNoise2D } from 'simplex-noise';

/* ——— Buckets (avec hystérésis) ——— */
const BUCKETS = [
  { id:'desktop-32:9', match:(w,h)=> w>=1025 && (w/h)>=3.1,                  grid:{cols:6, rows:2} },
  { id:'desktop-21:9', match:(w,h)=> w>=1025 && (w/h)>=2.0 && (w/h)<3.1,     grid:{cols:5, rows:2} },
  { id:'desktop-16:9', match:(w,h)=> (w/h)>=1.6 && (w/h)<2.0 && w>=768,      grid:{cols:4, rows:2} },

  { id:'tablet-4:3',   match:(w,h)=> (w/h)>=1.28 && (w/h)<1.6 && w>=641 && w<1025, grid:{cols:3, rows:2} },
  { id:'tablet-3:4',   match:(w,h)=> (h/w)>=1.2  && (h/w)<1.5 && w>=641 && w<1025, grid:{cols:2, rows:3} },
  { id:'tablet-9:16',  match:(w,h)=> (h/w)>=1.5  && w>=641 && w<1025,              grid:{cols:2, rows:4} },

  { id:'mobile-h',     match:(w,h)=> w<=640 && w>h, grid:{cols:3, rows:2} },
  { id:'mobile-v',     match:(w,h)=> w<=640 && h>=w, grid:{cols:2, rows:4} },
];
const HYST = 0.03;
let currentBucket = null;
let lastAspect = null;
function pickBucket(w, h){
  const a = w/h;
  if (currentBucket && lastAspect && Math.abs(a - lastAspect) < HYST) return currentBucket;
  for (const b of BUCKETS) { if (b.match(w, h)) { lastAspect = a; return b.id; } }
  lastAspect = a;
  return 'desktop-16:9';
}

/* ——— Couleurs & config ——— */
const prefersReducedMotion = matchMedia('(prefers-reduced-motion: reduce)').matches;
const COLORS = {
  background: 0x0055ff,
  square:     0x08090a,
  accent:     0xf7ff58,
  textCSS:    '#e5e5e5'
};
const config = {
  borderWidth: 0.005,
  backgroundColor: COLORS.background,
  darkColor: COLORS.square,
  cursorColor: COLORS.accent,
  initialProbabilityToSubdivide: 0.99,
  depthDecayFactor: 0.04,
  noiseScale: 1,
  minDepth: 1,
  maxDepthVariation: 7,
  mouseSquareAnimationSpeed: prefersReducedMotion ? 0.15 : 0.4,
  gridAnimationSpeed: prefersReducedMotion ? 0.05 : 0.08,
  grainOpacity: prefersReducedMotion ? 0.0 : 0.08,
  showDots: true,
  dotSize: 0.12,
  dotColor: COLORS.accent,
  dotSizeIsRelative: false
};

/* ——— Vœux d’images par bucket ——— */
const LAYOUT_WISH = {
  'desktop-32:9': { wantD1:1, wantD2:6, buttonsOnD2:true  },
  'desktop-21:9': { wantD1:1, wantD2:5, buttonsOnD2:true  },
  'desktop-16:9': { wantD1:1, wantD2:4, buttonsOnD2:true  },

  'tablet-4:3'  : { wantD1:1, wantD2:4, buttonsOnD2:true  },
  'tablet-3:4'  : { wantD1:1, wantD2:4, buttonsOnD2:false }, /* portrait : tolère D1 */
  'tablet-9:16' : { wantD1:1, wantD2:4, buttonsOnD2:false },

  'mobile-h'    : { wantD1:0, wantD2:4, buttonsOnD2:true  },
  'mobile-v'    : { wantD1:0, wantD2:4, buttonsOnD2:true  }
};

/* ——— Catégories (3 uniques) ——— */
const CATEGORIES = [
  { key:'motion',  label:'Motion\\nDesign',   url:'/motion-design' },
  { key:'fractal', label:'Fractal\\nArt',     url:'/fractal-art'   },
  { key:'code',    label:'Creative\\nCoding', url:'/creative-coding' }
];
const REQUIRED_BUTTONS = 3;

/* ——— Runtime state ——— */
let scene, camera, renderer, noise2D, rngFn, mouseSquare, cursorBorder, grainPlane, menuPlane, menuBorderBottom;
let lastMouseScreenPos = new THREE.Vector2(0, 0);
const fractalState = new Map(); const meshPool = []; const dotMeshPool = [];
let targetState = new Map();
let darkMaterial, cursorMaterial, geometry, dotMaterial, menuBorderMaterial;
let needsBaseUpdate = true; let needsRefineCheck = false; let refineBudgetPerFrame = 64;

const imageCells = new Set(); const buttonCells = new Map(); let persistentButtonPaths = [];
const imageAssignment = new Map(); const imageSlots = new Set(); const buttonSlots = new Set();
const materialCache = new Map(); const textureLoader = new THREE.TextureLoader();

let baseCols = 4, baseRowsPrimary = 2, WANT_D1 = 1, WANT_D2 = 4, BUTTONS_ON_D2 = true;
let TARGET_DEPTH = prefersReducedMotion ? 5 : 7;

/* ——— Images ——— */
const imageTextures = [
  'https://picsum.photos/1280?1',
  'https://picsum.photos/1280?2',
  'https://picsum.photos/1280?3',
  'https://picsum.photos/1280?4',
  'https://picsum.photos/1280?5',
  'https://picsum.photos/1280?6',
  'https://picsum.photos/1280?7',
  'https://picsum.photos/1280?8'
];

/* ——— Utils ——— */
function hashCode(str){ let h=0; for(let i=0;i<str.length;i++) h=((h<<5)-h+str.charCodeAt(i))|0; return h; }
function saltedKey(path, salt){ return (hashCode(path) ^ salt) | 0; }
const sessionSalt = (Math.random()*0x7fffffff) | 0; // sel aléatoire par session

function reseed(){
  rngFn = Math.random;
  noise2D = createNoise2D(Math.random); // nouvelle permutation aléatoire
}

/* Layout helpers */
function getLayoutMetrics(){
  const viewHeight = camera.top - camera.bottom;
  const viewWidth  = camera.right - camera.left;
  const w = viewWidth / baseCols;
  const menuHeight = Math.max(w / 8, 0.5);
  const contentTop = camera.top - menuHeight;

  // Synchronise la hauteur du header CSS au tout premier frame
  const pxMenu = (menuHeight / viewHeight) * window.innerHeight;
  document.documentElement.style.setProperty('--menu-h', `${pxMenu}px`);

  return { viewHeight, viewWidth, w, menuHeight, contentTop };
}
function isFullyVisible(x, y, size, contentTop){
  const eps = config.borderWidth * 2;
  const half = size / 2;
  return (
    x - half >= camera.left + eps &&
    x + half <= camera.right - eps &&
    y - half >= camera.bottom + eps &&
    y + half <= contentTop - eps
  );
}
function depth2SlotKey(x, y, w, contentTop){
  const cell = w/2;
  const col = Math.floor((x - camera.left) / cell);
  const row = Math.floor((contentTop - y) / cell);
  return `${col},${row}`;
}
function depth1SlotKey(x, y, w, contentTop){
  const cell = w;
  const col = Math.floor((x - camera.left) / cell);
  const row = Math.floor((contentTop - y) / cell);
  return `D1:${col},${row}`;
}
function key2col(key){
  const k = key.startsWith('D1:') ? key.slice(3) : key;
  return parseInt(k.split(',')[0],10);
}
function isAdjacentIn(set, key){
  const m = key.startsWith('D1:') ? key.slice(3) : key;
  const [c,r]=m.split(',').map(Number);
  const neigh = [[c-1,r],[c+1,r],[c,r-1],[c,r+1]];
  if (set.has(key)) return true;
  for (const [cc,rr] of neigh){
    const k2 = key.startsWith('D1:') ? `D1:${cc},${rr}` : `${cc},${rr}`;
    if (set.has(k2)) return true;
  }
  return false;
}
const isLandscape = ()=> window.innerWidth >= window.innerHeight;

/* THREE init */
const canvas = document.createElement('canvas'); canvas.id = 'webgl-canvas'; document.body.appendChild(canvas);

init();
bootstrap();
animate();

function init(){
  scene = new THREE.Scene(); scene.background = new THREE.Color(config.backgroundColor);

  const aspect = window.innerWidth / window.innerHeight; const height = 10; const width = height * aspect;
  camera = new THREE.OrthographicCamera(-width/2, width/2, height/2, -height/2, 1, 1000); camera.position.z = 10;

  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, canvas, powerPreference:'high-performance' });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));
  renderer.setSize(window.innerWidth, window.innerHeight);

  geometry = new THREE.PlaneGeometry(1,1);
  cursorMaterial = new THREE.MeshBasicMaterial({ color: config.cursorColor, transparent:true, opacity:0.85 });
  darkMaterial   = new THREE.MeshBasicMaterial({ color: config.darkColor });
  dotMaterial    = new THREE.MeshBasicMaterial({ color: config.dotColor });
  menuBorderMaterial = new THREE.MeshBasicMaterial({ color: config.backgroundColor });

  mouseSquare = new THREE.Mesh(geometry, cursorMaterial); mouseSquare.userData.targetPosition = new THREE.Vector3(); mouseSquare.userData.targetScale = new THREE.Vector3(); mouseSquare.renderOrder = 4; scene.add(mouseSquare);
  cursorBorder = new THREE.Mesh(geometry, darkMaterial); cursorBorder.userData.targetPosition = new THREE.Vector3(); cursorBorder.userData.targetScale = new THREE.Vector3(); cursorBorder.renderOrder = 3; scene.add(cursorBorder);

  createGrainPlane(); createMenuPlane();

  // interactions
  window.addEventListener('mousemove', onMouseMove, { passive:true });
  window.addEventListener('click', onClick, { passive:true });

  // hauteur header correcte au 1er frame
  requestAnimationFrame(()=>{ updateMenuGeometry(); });
}

function bootstrap(){
  const w = window.innerWidth, h = window.innerHeight;
  currentBucket = pickBucket(w, h);
  applyBucket();
  resetFractalRandom();
}

function applyBucket(){
  const b = BUCKETS.find(x=>x.id===currentBucket);
  baseCols = b?.grid.cols || 4;
  baseRowsPrimary = b?.grid.rows || 2;
  const wish = LAYOUT_WISH[currentBucket] || { wantD1:1, wantD2:4, buttonsOnD2:true };
  WANT_D1 = wish.wantD1; WANT_D2 = wish.wantD2; BUTTONS_ON_D2 = wish.buttonsOnD2;
}

/* Grain + Menu */
function createGrainPlane(){
  const mat = new THREE.ShaderMaterial({
    transparent: true,
    uniforms: { uOpacity: { value: config.grainOpacity } },
    vertexShader: 'varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }',
    fragmentShader:'uniform float uOpacity; varying vec2 vUv; float r(vec2 st){ return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);} void main(){ vec2 uv=gl_FragCoord.xy/512.0; float g=r(uv); gl_FragColor=vec4(1.0,1.0,1.0,g*uOpacity); }'
  });
  grainPlane = new THREE.Mesh(new THREE.PlaneGeometry(1,1), mat);
  grainPlane.position.z = 1; grainPlane.renderOrder = 2; scene.add(grainPlane);
  updateGrainPlaneSize();
}
function createMenuPlane(){
  menuPlane = new THREE.Mesh(new THREE.PlaneGeometry(1,1), darkMaterial); menuPlane.position.z = 0.1; menuPlane.renderOrder = 0; scene.add(menuPlane);
  menuBorderBottom = new THREE.Mesh(new THREE.PlaneGeometry(1,1), menuBorderMaterial); menuBorderBottom.position.z = 0.11; menuBorderBottom.renderOrder = 1; scene.add(menuBorderBottom);
  updateMenuGeometry();
}
function updateMenuGeometry(){
  const { viewHeight, viewWidth, w } = getLayoutMetrics();
  const menuHeight = Math.max(w/8, 0.5);
  const contentTop = camera.top - menuHeight;
  menuPlane.scale.set(viewWidth, menuHeight, 1);
  menuPlane.position.set((camera.left+camera.right)/2, camera.top - menuHeight/2, 0.1);
  menuBorderBottom.scale.set(viewWidth, config.borderWidth, 1);
  menuBorderBottom.position.set((camera.left+camera.right)/2, contentTop, 0.11);
}
function updateGrainPlaneSize(){ if(!grainPlane) return; const h=camera.top - camera.bottom; const w=camera.right - camera.left; grainPlane.scale.set(w, h, 1); }

/* Resize (debounced reload at resize end) */
let resizeTimer=null;
window.addEventListener('resize', ()=>{
  const aspect = window.innerWidth / window.innerHeight; const height = 10; const width = height * aspect;
  camera.left=-width/2; camera.right=width/2; camera.top=height/2; camera.bottom=-height/2; camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  updateGrainPlaneSize(); updateMenuGeometry();

  if (resizeTimer) clearTimeout(resizeTimer);
  resizeTimer = setTimeout(()=>{
    window.location.reload(); // recharge après la fin du redimensionnement
  }, 250);
}, { passive:true });

/* QuadTree / Build */
function resetFractalRandom(){
  // tente plusieurs fois de suite de construire une grille valide (3 boutons uniques)
  for (let tries=0; tries<50; tries++){
    reseed(); // RNG + noise aléatoires
    targetState.clear(); imageCells.clear(); buttonCells.clear();
    imageAssignment.clear(); imageSlots.clear(); buttonSlots.clear();
    const ok = updateFractalBase(true); // true si 3 boutons bien placés ET uniques
    if (ok){
      syncStateToMeshes();
      needsBaseUpdate = false;
      return;
    }
  }
  // en dernier recours, on force quand même un affichage : on place les 3 catégories
  // sur les 3 premières cases content visibles, puis on synchronise.
  ensureFallbackButtons();
  syncStateToMeshes();
  needsBaseUpdate = false;
}
function createQuadTree(x, y, size, depth, path, maxDepthOverride=-1){
  const noiseVal = (noise2D(x*config.noiseScale, y*config.noiseScale)+1)/2;
  const regionalMaxDepth = maxDepthOverride !== -1 ? maxDepthOverride : config.minDepth + Math.floor(noiseVal * config.maxDepthVariation);
  const currentProbability = config.initialProbabilityToSubdivide - depth * config.depthDecayFactor;
  const stop = depth >= regionalMaxDepth || (depth>0 && rngFn()>currentProbability) || size/2 <= config.borderWidth;
  if (stop){
    const scale = size - config.borderWidth;
    if (scale > 0) targetState.set(path, { x, y, size:scale, depth, path, originalSize:size });
    return;
  }
  const ns = size/2, o = size/4, d = depth+1;
  createQuadTree(x-o, y+o, ns, d, path+'/0', maxDepthOverride);
  createQuadTree(x+o, y+o, ns, d, path+'/1', maxDepthOverride);
  createQuadTree(x-o, y-o, ns, d, path+'/2', maxDepthOverride);
  createQuadTree(x+o, y-o, ns, d, path+'/3', maxDepthOverride);
}

function updateFractalBase(forceFull=false){
  targetState.clear();
  const { w, contentTop } = getLayoutMetrics();

  // lignes visibles + fillers (pansements)
  const visibleRows = Math.ceil((contentTop - camera.bottom) / w);
  const totalRows   = Math.max(baseRowsPrimary, visibleRows);

  for (let row=0; row<totalRows; row++){
    const isPrimary = row < baseRowsPrimary;
    for (let col=0; col<baseCols; col++){
      const pref = isPrimary ? 'content' : 'filler';
      const path = `${pref}/${row}/${col}`;
      const x = camera.left + col*w + w/2;
      const y = contentTop - row*w - w/2;
      createQuadTree(x, y, w, 1, path);
    }
  }

  // Assurer assez de D2 pour 3 boutons + images moyennes
  ensureMinDepth2Cells(REQUIRED_BUTTONS + WANT_D2, WANT_D1);

  // Sélection : 3 boutons uniques (d’abord) puis images
  const okButtons = chooseButtonsThenImages(forceFull);

  // Subdivisions d'ambiance (hors images/boutons)
  if (okButtons) sprinkleRefinements(24);

  return okButtons;
}

function ensureMinDepth2Cells(required, preserveD1Count){
  const { w, contentTop } = getLayoutMetrics();
  let d1=[], d2=[];
  for (const [path,s] of targetState.entries()){
    if (!path.startsWith('content/')) continue;
    if (!isFullyVisible(s.x, s.y, s.originalSize, contentTop)) continue;
    if (Math.abs(s.originalSize - w)   < 1e-6) d1.push({path,s});
    if (Math.abs(s.originalSize - w/2) < 1e-6) d2.push({path,s});
  }
  if (d2.length >= required) return;

  d1.sort((a,b)=> hashCode(a.path) - hashCode(b.path));
  let remainingD1 = d1.length;

  for (const {path,s} of d1){
    if (d2.length >= required) break;
    if ((remainingD1 - 1) < preserveD1Count) break;
    targetState.delete(path); remainingD1--;

    const size=s.originalSize, ns=size/2, d=2, o=size/4;
    const quads = [
      {x:s.x-o, y:s.y+o, suffix:'/0'},
      {x:s.x+o, y:s.y+o, suffix:'/1'},
      {x:s.x-o, y:s.y-o, suffix:'/2'},
      {x:s.x+o, y:s.y-o, suffix:'/3'},
    ];
    for (const q of quads){
      if (!isFullyVisible(q.x, q.y, ns, contentTop)) continue;
      const p = path + q.suffix;
      targetState.set(p, { x:q.x, y:q.y, size:ns - config.borderWidth, depth:d, path:p, originalSize:ns });
      d2.push({ path:p, s:targetState.get(p) });
      if (d2.length >= required) break;
    }
  }
}

function isForbiddenD2Edge(key2){
  // Desktop/Tablet en paysage : interdire les colonnes w/2 extrêmes pour les boutons
  const id = currentBucket;
  const desktopOrTab = id.startsWith('desktop') || id.startsWith('tablet');
  if (!desktopOrTab) return false;
  if (!isLandscape()) return false;
  const c = key2col(key2);
  const nColsD2 = baseCols * 2;
  return (c===0) || (c===nColsD2-1);
}

function chooseButtonsThenImages(forceFull){
  imageCells.clear(); buttonCells.clear(); imageSlots.clear(); buttonSlots.clear();
  const { w, contentTop } = getLayoutMetrics();

  // Agréger D1 & D2 visibles
  const d1=[], d2=[];
  for (const [path,s] of targetState.entries()){
    if (!path.startsWith('content/')) continue;
    if (!isFullyVisible(s.x, s.y, s.originalSize, contentTop)) continue;
    if (Math.abs(s.originalSize - w)   < 1e-6) d1.push({ path, s, key1: depth1SlotKey(s.x,s.y,w,contentTop) });
    if (Math.abs(s.originalSize - w/2) < 1e-6) d2.push({ path, s, key2: depth2SlotKey(s.x,s.y,w,contentTop) });
  }
  const salt = sessionSalt ^ 0x9E3779B9;
  d1.sort((a,b)=> saltedKey(a.path, salt)      - saltedKey(b.path, salt));
  d2.sort((a,b)=> saltedKey(a.path, salt+777 ) - saltedKey(b.path, salt+777));

  /* 1) Choisir 3 cases boutons */
  const pickedBtn = [];
  if (BUTTONS_ON_D2) {
    // priorité D2 non adjacents, non bords extrêmes
    for (const it of d2) {
      if (pickedBtn.length>=REQUIRED_BUTTONS) break;
      if (isForbiddenD2Edge(it.key2)) continue;
      if (isAdjacentIn(buttonSlots, it.key2)) continue;
      pickedBtn.push(it.path); buttonSlots.add(it.key2);
    }
    // compléter si besoin (même adjacents)
    for (const it of d2) {
      if (pickedBtn.length>=REQUIRED_BUTTONS) break;
      if (isForbiddenD2Edge(it.key2)) continue;
      if (!pickedBtn.includes(it.path)) { pickedBtn.push(it.path); buttonSlots.add(it.key2); }
    }
    // Si toujours pas assez (rare), autoriser D1 (mobile/étroits)
    for (const it of d1) {
      if (pickedBtn.length>=REQUIRED_BUTTONS) break;
      if (isAdjacentIn(buttonSlots, it.key1)) continue;
      pickedBtn.push(it.path); buttonSlots.add(it.key1);
    }
    for (const it of d1) {
      if (pickedBtn.length>=REQUIRED_BUTTONS) break;
      if (!pickedBtn.includes(it.path)) { pickedBtn.push(it.path); buttonSlots.add(it.key1); }
    }
  } else {
    // Boutons en D1 prioritaire (tablettes portrait)
    for (const it of d1) {
      if (pickedBtn.length>=REQUIRED_BUTTONS) break;
      if (isAdjacentIn(buttonSlots, it.key1)) continue;
      pickedBtn.push(it.path); buttonSlots.add(it.key1);
    }
    for (const it of d1) {
      if (pickedBtn.length>=REQUIRED_BUTTONS) break;
      if (!pickedBtn.includes(it.path)) { pickedBtn.push(it.path); buttonSlots.add(it.key1); }
    }
    // backup D2
    for (const it of d2) {
      if (pickedBtn.length>=REQUIRED_BUTTONS) break;
      if (isForbiddenD2Edge(it.key2)) continue;
      if (isAdjacentIn(buttonSlots, it.key2)) continue;
      pickedBtn.push(it.path); buttonSlots.add(it.key2);
    }
    for (const it of d2) {
      if (pickedBtn.length>=REQUIRED_BUTTONS) break;
      if (!pickedBtn.includes(it.path)) { pickedBtn.push(it.path); buttonSlots.add(it.key2); }
    }
  }
  persistentButtonPaths = pickedBtn.slice(0, REQUIRED_BUTTONS);

  // Si 0/1/2 boutons => échec (rebuild immédiat dans reset)
  if (persistentButtonPaths.length < REQUIRED_BUTTONS){
    return false;
  }

  // Assigner 3 catégories UNIQUES (ordre aléatoire, jamais de doublon)
  const order = [0,1,2];
  for (let i=order.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [order[i],order[j]]=[order[j],order[i]]; }
  for (let i=0; i<REQUIRED_BUTTONS; i++){
    const path = persistentButtonPaths[i];
    if (path && targetState.has(path)) {
      const spec = CATEGORIES[order[i]];
      buttonCells.set(path, { label: spec.label, url: spec.url, key: spec.key });
    }
  }
  // Sécurité anti-doublons : remplace une 2e occurrence par la catégorie manquante
  const seen = new Map();
  const missing = new Set(CATEGORIES.map(c=>c.key));
  for (const p of persistentButtonPaths){
    const k = buttonCells.get(p)?.key;
    if (k){ missing.delete(k); seen.set(k, (seen.get(k)||0)+1); }
  }
  if (missing.size>0){
    const missingKeys = Array.from(missing);
    for (const [k,count] of seen.entries()){
      if (count>1 && missingKeys.length>0){
        let replaced = false;
        for (const p of persistentButtonPaths){
          const info = buttonCells.get(p);
          if (info?.key===k && replaced){
            const mKey = missingKeys.shift();
            const spec = CATEGORIES.find(c=>c.key===mKey);
            if (spec){ buttonCells.set(p, { label: spec.label, url: spec.url, key: spec.key }); }
            break;
          }
          if (info?.key===k && !replaced){ replaced = true; }
        }
      }
    }
  }

  // Vérification finale stricte : 3 catégories présentes et toutes différentes
  {
    const keys = persistentButtonPaths.map(p=>buttonCells.get(p)?.key).filter(Boolean);
    const unique = new Set(keys);
    if (unique.size !== REQUIRED_BUTTONS) {
      return false;
    }
  }

  /* 2) Images — essayer 1 grande + WANT_D2 moyennes */
  const chosen = new Set();
  const buttonSet = new Set(persistentButtonPaths);
  const localImgSlots = new Set();

  // 1 grande (D1)
  if (WANT_D1>0) {
    for (const c of d1) {
      if (buttonSet.has(c.path)) continue;
      chosen.add(c.path);
      // occuper les 4 slots D2 internes pour limiter l’adjacence
      const half = w/2;
      const quads = [
        depth2SlotKey(c.s.x - half/2, c.s.y + half/2, w, contentTop),
        depth2SlotKey(c.s.x + half/2, c.s.y + half/2, w, contentTop),
        depth2SlotKey(c.s.x - half/2, c.s.y - half/2, w, contentTop),
        depth2SlotKey(c.s.x + half/2, c.s.y - half/2, w, contentTop),
      ];
      for (const k of quads){ localImgSlots.add(k); imageSlots.add(k); }
      break;
    }
  }

  // Moyennes (D2)
  let pickedD2 = 0;
  for (const c of d2) {
    if (pickedD2 >= WANT_D2) break;
    if (buttonSet.has(c.path)) continue;
    if (isAdjacentIn(localImgSlots, c.key2)) continue;
    chosen.add(c.path); localImgSlots.add(c.key2); imageSlots.add(c.key2); pickedD2++;
  }
  // Complément si pas assez (même adjacence)
  for (const c of d2) {
    if (pickedD2 >= WANT_D2) break;
    if (buttonSet.has(c.path)) continue;
    if (chosen.has(c.path)) continue;
    chosen.add(c.path); imageSlots.add(c.key2); pickedD2++;
  }

  for (const p of chosen) imageCells.add(p);

  // Assigner des textures sans doublon
  const used = new Set();
  for (const p of imageCells) if (imageAssignment.has(p)) used.add(imageAssignment.get(p));
  for (const p of imageCells) {
    if (!imageAssignment.has(p)) {
      let idx=0; while (used.has(idx) && idx<imageTextures.length) idx++;
      imageAssignment.set(p, idx); used.add(idx);
    }
  }
  for (const k of Array.from(imageAssignment.keys())) if (!imageCells.has(k)) imageAssignment.delete(k);

  return true;
}

/* Fallback ultime si jamais 3 boutons ne sont pas trouvés après 50 essais */
function ensureFallbackButtons(){
  const { w, contentTop } = getLayoutMetrics();
  const candidates = [];
  for (const [path,s] of targetState.entries()){
    if (!path.startsWith('content/')) continue;
    if (!isFullyVisible(s.x, s.y, s.originalSize, contentTop)) continue;
    candidates.push({ path, s });
  }
  candidates.sort((a,b)=> a.s.y===b.s.y ? a.s.x - b.s.x : b.s.y - a.s.y); // en haut-gauche -> droite
  const need = Math.min(REQUIRED_BUTTONS, candidates.length);
  const order = [0,1,2];
  for (let i=order.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [order[i],order[j]]=[order[j],order[i]]; }
  for (let i=0;i<need;i++){
    const p = candidates[i].path;
    const spec = CATEGORIES[order[i]];
    buttonCells.set(p, { label: spec.label, url: spec.url, key: spec.key });
    if (!persistentButtonPaths.includes(p)) persistentButtonPaths.push(p);
  }
}

/* Subdivisions d'ambiance non destructives */
function sprinkleRefinements(maxOps=24){
  const candidates = [];
  for (const [path,s] of targetState.entries()){
    if (!path.startsWith('content/')) continue;
    if (imageCells.has(path) || buttonCells.has(path)) continue;
    candidates.push({ path, s });
  }
  const salt = sessionSalt ^ 0xABCDEF;
  candidates.sort((a,b)=> saltedKey(a.path, salt) - saltedKey(b.path, salt));
  let ops=0;
  for (const it of candidates){
    if (ops>=maxOps) break;
    // subdivise 1 fois si possible
    if (it.s.depth < TARGET_DEPTH) {
      targetState.delete(it.path);
      const { x,y, originalSize:os, depth:d, path:p } = it.s;
      const ns = os/2, nd = d+1, o = os/4;
      createQuadTree(x-o, y+o, ns, nd, p+'/0', -1);
      createQuadTree(x+o, y+o, ns, nd, p+'/1', -1);
      createQuadTree(x-o, y-o, ns, nd, p+'/2', -1);
      createQuadTree(x+o, y-o, ns, nd, p+'/3', -1);
      ops++;
    }
  }
}

/* Materials */
function getImageMaterial(url){
  if (materialCache.has(url)) return materialCache.get(url);
  const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, map: null });
  textureLoader.load(url, tex=>{
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
    mat.map = tex; mat.needsUpdate = true;
  });
  materialCache.set(url, mat);
  return mat;
}
function makeTopRightLabelSprite(text, squareSize){
  const lines = text.split('\\n');
  const cvs = document.createElement('canvas'); const W=1024, H=768;
  cvs.width = W; cvs.height = H;
  const ctx = cvs.getContext('2d');
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = COLORS.textCSS;
  ctx.textBaseline = 'top'; ctx.textAlign = 'right';
  const fontPx = Math.floor(H * 0.11);
  ctx.font = `700 ${fontPx}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace`;
  const margin = Math.floor(H * 0.08); const lineGap = Math.floor(fontPx * 0.12);
  let y = margin; for (const line of lines){ ctx.fillText(line, W - margin, y); y += fontPx + lineGap; }
  const tex = new THREE.CanvasTexture(cvs); tex.colorSpace = THREE.SRGBColorSpace;
  const sprMat = new THREE.SpriteMaterial({ map: tex, depthTest:false, depthWrite:false, transparent:true, color: new THREE.Color(COLORS.textCSS) });
  const spr = new THREE.Sprite(sprMat); const aspect = H/W; spr.scale.set(squareSize, squareSize*aspect, 1); spr.center.set(1,1); spr.renderOrder = 6; return spr;
}

/* Sync meshes */
function syncStateToMeshes(){
  const newKeys = new Set(targetState.keys());
  for (const [key, st] of Array.from(fractalState.entries())){
    if (!newKeys.has(key)) {
      st.targetScale.set(0,0,0);
      if (st.dotMesh) st.dotMesh.scale.set(0,0,0);
      if (st.labelSprite) { scene.remove(st.labelSprite); st.labelSprite=null; }
    }
  }
  for (const key of newKeys){
    const t = targetState.get(key); const ex = fractalState.get(key);
    const isImg = imageCells.has(key); const isBtn = buttonCells.has(key);
    let material = darkMaterial;
    if (isImg) {
      const idx = imageAssignment.get(key); const url = imageTextures[idx];
      material = getImageMaterial(url);
    }
    if (ex){
      ex.targetPosition.set(t.x, t.y, 0); ex.targetScale.set(t.size, t.size, 1);
      if (ex.mesh.material !== material) ex.mesh.material = material;
      if (ex.labelSprite && !isBtn) { scene.remove(ex.labelSprite); ex.labelSprite=null; }
      if (isBtn) {
        const label = buttonCells.get(key)?.label || '';
        if (!ex.labelSprite) {
          const spr = makeTopRightLabelSprite(label, t.size);
          const m = t.size*0.03; spr.position.set(t.x + t.size/2 - m, t.y + t.size/2 - m, 0.2);
          ex.labelSprite=spr; scene.add(spr);
        } else {
          const m = ex.targetScale.x*0.03; ex.labelSprite.position.set(t.x + t.size/2 - m, t.y + t.size/2 - m, 0.2);
          ex.labelSprite.scale.set(ex.targetScale.x, ex.targetScale.x*0.75, 1);
        }
      }
      ex.isButton=isBtn; ex.isImage=isImg;
    } else {
      const mesh = meshPool.pop() || new THREE.Mesh(geometry);
      mesh.material = material; mesh.position.set(t.x,t.y,0); mesh.scale.set(0,0,0); mesh.renderOrder = 0; scene.add(mesh);
      const st = { mesh, dotMesh:null, labelSprite:null, targetPosition:new THREE.Vector3(t.x,t.y,0), targetScale:new THREE.Vector3(t.size,t.size,1), originalSize:t.originalSize, isButton:isBtn, isImage:isImg, hover:false };
      fractalState.set(key, st);
      if (!isImg && config.showDots) addDotToState(st);
      if (isBtn) {
        const label = buttonCells.get(key)?.label || '';
        const spr = makeTopRightLabelSprite(label, t.size);
        const m = t.size*0.03; spr.position.set(t.x + t.size/2 - m, t.y + t.size/2 - m, 0.2);
        st.labelSprite = spr; scene.add(spr);
      }
    }
  }
}
function getDotScale(state){
  const cappedDotSize = Math.min(0.5, config.dotSize);
  if (config.dotSizeIsRelative) return state.mesh.scale.x * cappedDotSize;
  const viewHeight = camera.top - camera.bottom; const viewWidth = camera.right - camera.left; const gridSize = Math.max(viewWidth, viewHeight); const baseSize = gridSize / 256; return baseSize * cappedDotSize;
}
function addDotToState(st){ if (st.dotMesh) return; st.dotMesh = dotMeshPool.pop() || new THREE.Mesh(geometry, dotMaterial); st.dotMesh.position.copy(st.mesh.position); st.dotMesh.renderOrder = 0; scene.add(st.dotMesh); const sc = getDotScale(st); st.dotMesh.scale.set(sc, sc, 1); }

/* Anim */
function animate(){
  requestAnimationFrame(animate);
  if (needsBaseUpdate){ 
    const ok = updateFractalBase(false);
    if (ok) { syncStateToMeshes(); }
    needsBaseUpdate=false;
  }
  if (needsRefineCheck){
    const wp = new THREE.Vector3(lastMouseScreenPos.x, lastMouseScreenPos.y, 0).unproject(camera);
    if (refineTargetStateAt(wp)) syncStateToMeshes();
    updateMouseSquareTarget(wp); needsRefineCheck=false;
  }

  mouseSquare.position.lerp(mouseSquare.userData.targetPosition, config.mouseSquareAnimationSpeed);
  mouseSquare.scale.lerp(mouseSquare.userData.targetScale, config.mouseSquareAnimationSpeed);
  cursorBorder.position.lerp(cursorBorder.userData.targetPosition, config.mouseSquareAnimationSpeed);
  cursorBorder.scale.lerp(cursorBorder.userData.targetScale, config.mouseSquareAnimationSpeed);

  let hoverAny=false;
  for (const [key, st] of Array.from(fractalState.entries())){
    if (st.isButton) {
      st.mesh.position.copy(st.targetPosition); st.mesh.scale.copy(st.targetScale);
      if (st.labelSprite){
        const m = st.targetScale.x * 0.03;
        st.labelSprite.position.set(st.targetPosition.x + (st.targetScale.x/2 - m), st.targetPosition.y + (st.targetScale.x/2 - m), 0.2);
        st.labelSprite.scale.set(st.targetScale.x, st.targetScale.x*0.75, 1);
      }
    } else {
      st.mesh.position.lerp(st.targetPosition, config.gridAnimationSpeed);
      st.mesh.scale.lerp(st.targetScale, config.gridAnimationSpeed);
    }

    if (st.isButton && st.labelSprite){
      const wp = new THREE.Vector3(lastMouseScreenPos.x, lastMouseScreenPos.y, 0).unproject(camera);
      const half = st.targetScale.x/2;
      const inside = (wp.x>=st.targetPosition.x-half && wp.x<=st.targetPosition.x+half && wp.y>=st.targetPosition.y-half && wp.y<=st.targetPosition.y+half);
      if (inside){ st.labelSprite.material.color.set(COLORS.accent); hoverAny=true; }
      else       { st.labelSprite.material.color.setStyle(COLORS.textCSS); }
    }

    if (st.dotMesh){ st.dotMesh.position.copy(st.mesh.position); if (st.isImage && st.dotMesh.scale.x>0) st.dotMesh.scale.set(0,0,0); }

    if (st.mesh.scale.x < 0.001 && st.targetScale.x===0){
      scene.remove(st.mesh); meshPool.push(st.mesh);
      if (st.dotMesh){ scene.remove(st.dotMesh); dotMeshPool.push(st.dotMesh); }
      if (st.labelSprite){ scene.remove(st.labelSprite); }
      fractalState.delete(key);
    }
  }
  document.body.style.cursor = hoverAny ? 'pointer' : 'default';

  renderer.render(scene, camera);
  const canvas = document.getElementById('webgl-canvas');
  if (canvas && canvas.style.opacity!=='1') canvas.style.opacity='1';
}

function findLeafAt(worldPos, stateMap){
  let best=null, smallest=Infinity;
  for (const sq of stateMap.values()){
    const half = sq.originalSize/2;
    const inside = worldPos.x>=sq.x-half && worldPos.x<=sq.x+half && worldPos.y>=sq.y-half && worldPos.y<=sq.y+half;
    if (inside && sq.originalSize<smallest){ best=sq; smallest=sq.originalSize; }
  }
  return best;
}
function refineTargetStateAt(worldPos){
  let refined=false, it=0;
  while (it<refineBudgetPerFrame){
    it++;
    const leaf = findLeafAt(worldPos, targetState); if (!leaf) break;
    if (imageCells.has(leaf.path) || buttonCells.has(leaf.path)) break;
    if (leaf.depth < TARGET_DEPTH){
      refined=true; targetState.delete(leaf.path);
      const {x,y, originalSize:os, depth:d, path:p} = leaf; const ns=os/2, nd=d+1, o=os/4;
      createQuadTree(x-o, y+o, ns, nd, p+'/0', -1);
      createQuadTree(x+o, y+o, ns, nd, p+'/1', -1);
      createQuadTree(x-o, y-o, ns, nd, p+'/2', -1);
      createQuadTree(x+o, y-o, ns, nd, p+'/3', -1);
    } else break;
  }
  return refined;
}
function updateMouseSquareTarget(worldPos){
  const leaf = findLeafAt(worldPos, targetState); if (!leaf) return;
  const dd = Math.max(0, TARGET_DEPTH - leaf.depth); const cell = leaf.originalSize / Math.pow(2, dd);
  const lx = worldPos.x - (leaf.x - leaf.originalSize/2); const ly = worldPos.y - (leaf.y - leaf.originalSize/2);
  const ix = Math.max(0, Math.min(Math.floor(lx / cell), Math.pow(2, dd)-1)); const iy = Math.max(0, Math.min(Math.floor(ly / cell), Math.pow(2, dd)-1));
  const nx = (leaf.x - leaf.originalSize/2) + ix*cell + cell/2; const ny = (leaf.y - leaf.originalSize/2) + iy*cell + cell/2; const fs = Math.max(0, cell - config.borderWidth);
  mouseSquare.userData.targetPosition.set(nx,ny,4); mouseSquare.userData.targetScale.set(fs,fs,1);
  cursorBorder.userData.targetPosition.set(nx,ny,3); cursorBorder.userData.targetScale.set(fs+config.borderWidth, fs+config.borderWidth, 1);
}

/* Mouse & Click */
function onMouseMove(e){
  lastMouseScreenPos.set((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
  needsRefineCheck = true;
}
function onClick(){
  const wp = new THREE.Vector3(lastMouseScreenPos.x,lastMouseScreenPos.y,0).unproject(camera);
  for (const [key, st] of fractalState.entries()){
    if (!st.isButton) continue;
    const half = st.targetScale.x/2;
    const inside = (wp.x>=st.targetPosition.x-half && wp.x<=st.targetPosition.x+half && wp.y>=st.targetPosition.y-half && wp.y<=st.targetPosition.y+half);
    if (inside && buttonCells.has(key)){ const {url}=buttonCells.get(key); window.location.href = url; return; }
  }
  // clic ailleurs => nouveau layout aléatoire
  resetFractalRandom();
}

</script>
</body>
</html>
