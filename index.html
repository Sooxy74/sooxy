<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fractale — Desktop preset (référence)</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<link rel="preconnect" href="https://cdn.skypack.dev" crossorigin>
<link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,700;1,400&display=swap" rel="stylesheet">

<style>
  :root {
    color-scheme: dark;
    --menu-h: 48px;
    --menu-gap: 16px;
    --doc-h: 100vh;
  }
  html, body { height: 100%; }

    /* Masquer la souris au-dessus de la scène (canvas + labels) */
    #webgl-canvas,
    #labels-layer {
     cursor: none !important;
    }

    /* Masquer la flèche aussi sur le header */
    #ui-header, #ui-header * {
        cursor: none !important;
    }

    /* Carré-curseur DOM au-dessus du menu */
    #cursor-overlay{
        position: fixed;
        left: 0; top: 0;
        width: 0; height: 0;
        pointer-events: none;
        transform: translate(-50%, -50%);
        z-index: 6;           /* > header(4) et > labels(5) si nécessaire */
        opacity: 0;           /* on l'affiche seulement dans le header */
    }
    #cursor-overlay .inner{
      width: 100%;
      height: 100%;
      background: #f3ff00;
      opacity: .85;
      box-shadow: 0 0 0 1px #11190c inset;
    }


  body {
    margin: 0; overflow: auto;
    background-color: #0055ff;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  }
  #webgl-canvas {
    position: fixed; inset: 0; display: block; z-index: 1;
    opacity: 0; transition: opacity .25s ease;
  }
  #ui-header {
  position: fixed;
  top: 0; left: 0; right: 0;
  height: var(--menu-h);
  z-index: 4;
  pointer-events: none;

  /* fond opaque = rend le chevauchement impossible visuellement */
  background: #11190c;
  }

  
  #ui-header::after {
  content: "";
    position: absolute;
    left: 0; right: 0; bottom: 0;
    height: 1px;                 /* vrai 1px CSS, toujours net */
    background: #0055ff;         /* même bleu que le fond */
    transform: translateZ(0);     /* évite le flou sub-pixel */
  }

  #header-inner {
    height: 100%; display: flex; align-items: center; justify-content: flex-end;
    padding: 0 var(--menu-gap);
    padding-right: calc(var(--menu-gap) * 2);
    box-sizing: border-box; pointer-events: none; position: relative;
  }
  #nav-links { display: flex; gap: calc(var(--menu-gap) * 2); align-items: center; white-space: nowrap; pointer-events: auto; }
  .nav-btn {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
    font-size: 14px; color: #f3f1ee; letter-spacing: .02em; text-decoration: none;
  }
  .nav-btn:hover, .nav-btn:focus { outline: none; color: #f3ff00; }
  
  /* Animation des boutons du menu */
  /* Animation des boutons du menu — sans délai CSS */
  
  #nav-links .nav-btn {
  position: relative;
  display: inline-block;
  overflow: hidden;      /* masque les lettres qui bougent */
  line-height: 1.1;
}

  #nav-links .nav-btn .text-container {
    position: relative;
    display: block;
    top: -1px;             /* petit ajustement vertical */
  /* pas de transition CSS ici */
  }

  #nav-links .nav-btn .button-text {
    display: block;
    white-space: nowrap;
  }

  #nav-links .nav-btn .letter {
    display: inline-block;
    /* pas de transition CSS ici — GSAP gère tout */
    will-change: transform;
  }


  /* garde ta couleur : la couleur au survol reste gérée par .nav-btn:hover */

  #logo-link { pointer-events: auto; display: inline-flex; align-items: center; justify-content: center;
    margin-left: calc(var(--menu-gap) * 2);
  }
  #logo-overlay {
    height: calc(var(--menu-h) * 0.5);
    max-height: 44px;
    aspect-ratio: auto; display: block; user-select: none;
  }
  #mobile-left, #mobile-right {
    display: none; pointer-events: auto; color: #f3f1ee;
    position: absolute; top: 50%; transform: translateY(-50%);
  }

  #mobile-left  { left: var(--menu-gap); }
  #mobile-right { right: var(--menu-gap); }
  .mobile-icon {
  display: block;
    /* taille réactive basée sur la hauteur du header */
    width:  calc(var(--menu-h) * 1.00);
    height: calc(var(--menu-h) * 1.00);
  }

  @media (max-width: 640px) {
    #header-inner { justify-content: center; }
    #nav-links { display: none; }
    #logo-link { margin-left: 0; }
    #mobile-left, #mobile-right { display: inline-flex; align-items: center; }
  }
  #scroll-spacer { height: var(--doc-h); }
  
  /* Les labels doivent passer SOUS le header (z=4) */
  /* Les labels ne doivent JAMAIS recouvrir la zone du header */
  /* Les labels ne doivent pas recouvrir le header,
   mais sans marge supplémentaire */
  #labels-layer{
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 3;
    clip-path: inset(var(--menu-h) 0 0 0); /* ⬅️ plus de + 8px */
  }



.hover-label{
  position:absolute;
  font:700 18px ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Courier New",monospace;
  color:#f3f1ee; line-height:1;
  transition:opacity .15s ease, color .15s ease;
  transform:translate(-100%,0);
  transform-origin:100% 0%;
  text-align:right; white-space:normal;
  will-change:transform,opacity,color,width;
}

.hover-label .line{ display:block; }

/* même interlignage au pixel près entre toutes les lignes */
.hover-label .line.sub{
  font-style: italic;
  font-weight: 400;          /* pas bold */
  font-size: .6em;           /* 60% */
  line-height: 1.6667;       /* = 1 / 0.6 -> 1em en absolu */
  font-family: "Space Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
}
  
  @media (prefers-reduced-motion: reduce) { #webgl-canvas { transition: none; } }
</style>
  <script src="https://cdn.jsdelivr.net/npm/baffle@0.3.6/dist/baffle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js" defer></script>
</head>
<body>

<header id="ui-header" aria-label="Top menu">
  <div id="header-inner">
    <a id="mobile-left" href="#about" aria-label="About / Info">
      <svg class="mobile-icon" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <path fill="#f3f1ee" d="M119.5,61.73c-7.8,0-14.72,3.82-19,9.69-4.28-5.87-11.2-9.69-19-9.69h-26.5v68h33c4.68,0,8.49,3.81,8.5,8.49v.05s9-.04,9-.04c0-4.69,3.81-8.5,8.5-8.5h31V61.73h-25.5ZM88,120.73h-24v-50h17.5c8,0,14.5,6.5,14.5,14.5v.04l.35,37.58c-2.48-1.36-5.33-2.13-8.35-2.13ZM136,120.73h-22c-3.14,0-6.09.85-8.64,2.3l-.36-37.81c0-7.99,6.51-14.49,14.5-14.49h16.5v50Z"/>
      </svg>

    </a>
    <nav id="nav-links" aria-label="Primary">
      <a class="nav-btn" href="#about">[ ABOUT ]</a>
      <a class="nav-btn" href="#contact">[ CONTACT ]</a>
    </nav>
    <a id="logo-link" href="/" aria-label="Home">
      <img id="logo-overlay" src="img/logo-sooxy-art.png" alt="Logo Sooxy Art" loading="eager" decoding="async" />
    </a>
    <a id="mobile-right" href="#contact" aria-label="Contact">
      <svg class="mobile-icon" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <path fill="#f3f1ee" d="M55,136h90v-72H55v72ZM64,73h72v7.29l-36.47,23.82-35.53-23.85v-7.25ZM64,91.09l35.47,23.81,36.53-23.86v35.96h-72v-35.91Z"/>
      </svg>

    </a>
  </div>
</header>

<div id="scroll-spacer" aria-hidden="true"></div>
  
<div id="labels-layer" aria-hidden="true"></div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
    "simplex-noise": "https://cdn.skypack.dev/simplex-noise@4.0.1"
  }
}
</script>

<script type="module">
// Imports
import * as THREE from 'three';
import { createNoise2D } from 'simplex-noise';

// Buckets (avec hystérésis)
const BUCKETS = [
  { id:'desktop-32:9', match:(w,h)=> w>=1025 && (w/h)>=3.1,                  grid:{cols:6, rows:2} },
  { id:'desktop-21:9', match:(w,h)=> w>=1025 && (w/h)>=2.0 && (w/h)<3.1,     grid:{cols:5, rows:2} },
  { id:'desktop-16:9', match:(w,h)=> (w/h)>=1.6 && (w/h)<2.0 && w>=768,      grid:{cols:4, rows:2} },
  { id:'tablet-4:3',   match:(w,h)=> (w/h)>=1.28 && (w/h)<1.6 && w>=641 && w<1025, grid:{cols:3, rows:2} },
  { id:'tablet-3:4',   match:(w,h)=> (h/w)>=1.2  && (h/w)<1.5 && w>=641 && w<1025, grid:{cols:2, rows:3} },
  { id:'tablet-9:16',  match:(w,h)=> (h/w)>=1.5  && w>=641 && w<1025,              grid:{cols:2, rows:4} },
  { id:'mobile-h',     match:(w,h)=> w<=640 && w>h, grid:{cols:3, rows:2} },
  { id:'mobile-v',     match:(w,h)=> w<=640 && h>=w, grid:{cols:2, rows:4} },
];
const HYST = 0.03;
let currentBucket = null;
let lastAspect = null;
function pickBucket(w, h){
  const a = w/h;
  if (currentBucket && lastAspect && Math.abs(a - lastAspect) < HYST) return currentBucket;
  for (const b of BUCKETS) { if (b.match(w, h)) { lastAspect = a; return b.id; } }
  lastAspect = a;
  return 'desktop-16:9';
}

// Couleurs & config
const prefersReducedMotion = matchMedia('(prefers-reduced-motion: reduce)').matches;
const COLORS = {
  background: 0x0055ff,           // bleu
  square:     0x11190c,           // noir
  accent:     0xf3ff00,           // jaune
  textCSS:    '#f3f1ee',          // blanc (pour DOM/canvas)
  placeholder:'#CAC4B7'           // gris fallback images
};

const config = {
  borderWidth: 0.005,
  backgroundColor: COLORS.background,
  darkColor: COLORS.square,
  cursorColor: COLORS.accent,
  initialProbabilityToSubdivide: 0.99,
  depthDecayFactor: 0.04,
  noiseScale: 1,
  minDepth: 1,
  maxDepthVariation: 7,
  mouseSquareAnimationSpeed: prefersReducedMotion ? 0.15 : 0.4,
  gridAnimationSpeed: prefersReducedMotion ? 0.05 : 0.08,
  grainOpacity: prefersReducedMotion ? 0.0 : 0.08,
  showDots: true,
  dotSize: 0.12,
  dotColor: COLORS.accent,
  dotSizeIsRelative: false,
  baseColsOverride: null,

  // --- Nouveaux réglages pour les labels ---
  // Plus PETIT = plus rapide (intervalle d'update baffle, en ms)
  labelBaffleSpeedMs: 30,
  // Plus PETIT = plus rapide (durée de révélation au survol, en ms)
  labelRevealMs: 50,
    // --- ALÉATOIRE SUR LES D2 ---
  refineChanceD2: 0.55,           // probabilité qu'un carré w/2 soit subdivisé
  extraChildChanceAfterD2: 0.30,  // petite chance de raffiner encore un enfant

};
  
// --- Labels DOM (effet baffle) ---
const LABEL_MARGIN_PCT_RIGHT = 1/16; // 6.25% du côté du bouton
const LABEL_MARGIN_PCT_TOP   = 1/16; // 6.25% du côté du bouton
const LABEL_NUDGE_PX_Y       = -2;
const LABEL_RIGHT_EXTRA_PX   = 1;

// marge dure (px) sous le header pour empêcher tout chevauchement visuel
const SAFE_TOP_GAP_PX          = 0;


function worldToClientXY(v3){
  const v = v3.clone().project(camera);
  return { x:(v.x*0.5+0.5)*window.innerWidth, y:(-v.y*0.5+0.5)*window.innerHeight };
}
function makeDomLabelEl(text){
  const el = document.createElement('div');
  el.className = 'hover-label';
  const parts = String(text).replace(/\\n/g, '\n').split('\n');
  el.innerHTML = parts.map((s,i)=>`<span class="line${i===2?' sub':''}">${s}</span>`).join('');
  return el;
}
  
// Vœux d’images par bucket
const LAYOUT_WISH = {
  'desktop-32:9': { wantD1:2, wantD2:6, buttonsOnD2:true },
  'desktop-21:9': { wantD1:2, wantD2:5, buttonsOnD2:true },
  'desktop-16:9': { wantD1:3, wantD2:4, buttonsOnD2:true },
  'tablet-4:3'  : { wantD1:1, wantD2:4, buttonsOnD2:false },
  'tablet-3:4'  : { wantD1:1, wantD2:4, buttonsOnD2:false },
  'tablet-9:16' : { wantD1:1, wantD2:4, buttonsOnD2:false },
  // Mobile : on ne force aucune D2 via la grille, les boutons sont posés par-dessus
  'mobile-h'    : { wantD1:0, wantD2:0, buttonsOnD2:false },
  'mobile-v'    : { wantD1:0, wantD2:0, buttonsOnD2:false },
};


// Presets déterministes par bucket
//  row/col = case D1 (grille de base), quad ∈ {0,1,2,3} = sous-carré D2 :
//  0: haut-gauche, 1: haut-droit, 2: bas-gauche, 3: bas-droit
// Presets déterministes par bucket
//  row/col = case D1 (grille de base), quad ∈ {0,1,2,3} = sous-carré D2 :
//  0: haut-gauche, 1: haut-droit, 2: bas-gauche, 3: bas-droit
const PRESETS = {
  // Desktop 16:9 — suit la maquette : 5 boutons (rouges) en D2, images (vertes) en D1 et D2
  'desktop-16:9': {
    // Boutons (inchangé)
    buttons: [
      { size:'D2', row:0, col:1, quad:0, key:'motion'  },
      { size:'D2', row:0, col:2, quad:2, key:'ui'     },
      { size:'D2', row:1, col:0, quad:1, key:'fractal' },
      { size:'D2', row:1, col:3, quad:2, key:'random'  },
      { size:'D2', row:0, col:2, quad:1, key:'code'    }
    ],

    // Images plein w (D1) : on laisse seulement celles du haut
    imagesD1: [
      { row:0, col:0 },
      { row:0, col:3 }
    ],

    // Aucune image w/2 ici
    imagesD2: []
  },

  // Tablettes/Mobiles
  'tablet-4:3': {
    buttons: [
      { size:'D2', row:0, col:0, quad:0, key:'motion' },
      { size:'D2', row:0, col:1, quad:0, key:'ui'    },
      { size:'D2', row:0, col:2, quad:2, key:'fractal'},
      { size:'D2', row:1, col:0, quad:1, key:'random' },
      { size:'D2', row:1, col:2, quad:2, key:'code'   },
    ],
    imagesD1: [], imagesD2: [],
  },
  'tablet-3:4': {
    buttons: [
      { size:'D1', row:0, col:1, key:'motion'  },
      { size:'D1', row:1, col:0, key:'ui'     },
      { size:'D1', row:2, col:1, key:'fractal' },
      { size:'D1', row:3, col:0, key:'random'  },
      { size:'D1', row:4, col:1, key:'code'    },
    ],
    imagesD1: [], imagesD2: [],
  },
  'tablet-9:16': {
    buttons: [
      { size:'D1', row:0, col:1, key:'motion'  },
      { size:'D1', row:1, col:0, key:'ui'     },
      { size:'D1', row:2, col:1, key:'fractal' },
      { size:'D1', row:3, col:0, key:'random'  },
      { size:'D1', row:4, col:1, key:'code'    },
    ],
    imagesD1: [], imagesD2: [],
  },
    'mobile-v': {
    // Grille base: 2 colonnes x 4 rangées (BUCKETS mobile-v)
    // On place 5 boutons en D2 (w/2) avec un motif lisible en colonne
    buttons: [
      { size:'D2', row:0, col:0, quad:1, key:'motion'  }, // haut-gauche, quadrant haut-droit
      { size:'D2', row:1, col:1, quad:2, key:'ui'      }, // rangée 2, col droite, quadrant bas-gauche
      { size:'D2', row:2, col:0, quad:3, key:'fractal' }, // rangée 3, col gauche, quadrant bas-droit
      { size:'D2', row:3, col:1, quad:0, key:'random'  }, // rangée 4, col droite, quadrant haut-gauche
      { size:'D2', row:1, col:0, quad:0, key:'code'    }, // rangée 2, col gauche, quadrant haut-gauche
    ],
    imagesD1: [], imagesD2: [],
  },

  'mobile-h': {
    // Grille base: 3 colonnes x 2 rangées (BUCKETS mobile-h)
    // 5 boutons en D2 répartis sur la surface
    buttons: [
      { size:'D2', row:0, col:0, quad:1, key:'motion'  },
      { size:'D2', row:0, col:1, quad:2, key:'ui'      },
      { size:'D2', row:1, col:2, quad:0, key:'fractal' },
      { size:'D2', row:1, col:0, quad:3, key:'random'  },
      { size:'D2', row:0, col:2, quad:2, key:'code'    },
    ],
    imagesD1: [], imagesD2: [],
  },


  // Pas de preset spécifique → on déclenchera le fallback
  'desktop-21:9': null,
  'desktop-32:9': null,
};

// === helpers preset (global) ===
function presetForBucket(id){
  return PRESETS[id] || PRESETS['desktop-16:9'];
}

// Catégories (5 uniques)
const CATEGORIES = [
  { key:'motion',  label:'Motion\nDesign',       url:'/motion-design' },
  { key:'fractal', label:'Fractal\nArt',         url:'/fractal-art'   },
  { key:'code', label:'Creative\nCoding\nAI-assisted', url:'/creative-coding' },
  { key:'ui',     label:'UI\nDesign',          url:'/UI-design' },
  { key:'random',  label:'Random\nStuff',        url:'/random-stuff' }
];
const REQUIRED_BUTTONS = 5;

// Runtime state
let scene, camera, renderer, noise2D, rngFn, mouseSquare, cursorBorder, grainPlane, menuPlane, menuBorderBottom;
let lastMouseScreenPos = new THREE.Vector2(0, 0);
const fractalState = new Map(); const meshPool = []; const dotMeshPool = [];
let targetState = new Map();
let darkMaterial, cursorMaterial, geometry, dotMaterial, menuBorderMaterial;
let needsBaseUpdate = true; let needsRefineCheck = false; let refineBudgetPerFrame = 64;
const imageCells = new Set(); const buttonCells = new Map(); let persistentButtonPaths = [];
const imageAssignment = new Map(); const imageSlots = new Set(); const buttonSlots = new Set();
const materialCache = new Map(); const textureLoader = new THREE.TextureLoader();
let baseCols = 4, baseRowsPrimary = 2, WANT_D1 = 1, WANT_D2 = 4, BUTTONS_ON_D2 = true;
let TARGET_DEPTH = prefersReducedMotion ? 5 : 7;
let domCursorEl = null;
let cursorInHeader = false;
let lastGridCursorSizeWorld = 0;   // mémorise la taille utilisée dans la grille
let persistentImageUrls = null;



// Scroll vertical simulé en coordonnées monde
let scrollOffsetWorld = 0;
// Hauteur totale du contenu en "monde" pour le mobile (calculée dynamiquement)
let mobileWorldContentHeight = 0;

  
// Images locales (img/BY-pics/01.png, 02.png, 03.png, …)
let imageTextures = [];
const LOCAL_IMG_DIR = 'img/BY-pics/';
const IMG_EXT = '.png';
const IMG_PAD = 2;
const MAX_INDEX = 200;
const STOP_AFTER_MISSES = 10;

async function scanLocalImages() {
  imageTextures = [];
  let misses = 0;
  for (let i = 1; i <= MAX_INDEX; i++) {
    const num = String(i).padStart(IMG_PAD, '0');
    const url = `${LOCAL_IMG_DIR}${num}${IMG_EXT}`;
    const ok = await imageExists(url);
    if (ok) { imageTextures.push(url); misses = 0; }
    else {
      misses++;
      if (misses >= STOP_AFTER_MISSES && imageTextures.length > 0) break;
    }
  }
  // pas de duplication automatique : on garde uniquement les fichiers réellement présents
}


function imageExists(url) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
    img.src = url + '?v=' + Math.random();
  });
}

// Utils
function hashCode(str){ let h=0; for(let i=0;i<str.length;i++) h=((h<<5)-h+str.charCodeAt(i))|0; return h; }
function saltedKey(path, salt){ return (hashCode(path) ^ salt) | 0; }
const sessionSalt = (Math.random()*0x7fffffff) | 0;
function reseed(){ rngFn = Math.random; noise2D = createNoise2D(Math.random); }

/* ====== BLOC MOBILE DÉTERMINISTE (remplace l'ancien ASCII) ====== */
/*
Objectif mobile :
- 1 colonne de base (baseCols=1).
- 5 boutons catégorie en D2 (taille = w/2), alternance gauche/droite.
- Entre deux boutons successifs : espace vertical = w/4.
- Aspect : fond noir (pas d'image).
- Pas d'overlays, pas d'images sur mobile.
*/

// Mobile : ordre des catégories (5)
const USE_MOBILE_DETERMINISTIC = true;
const MOBILE_CATEGORY_ORDER = ['motion','fractal','ui','code','random'];

// Construit 5 gros carrés w/2 en diagonale (AUCUN espace avant le 1er)
// interlignes = w/4 entre les boutons uniquement
function buildMobileButtonsDeterministic(){
  const { w, contentTop } = getLayoutMetrics();

  const side = w;
  const gap  = w / 2;  // ⬅️ au lieu de w / 4
  const stepY = side + gap;
  const half = side / 2;

  // Centres des colonnes
  const xLeft  = camera.left + w * 0.5;
  const xRight = camera.left + w * 1.5;

  // 1er bouton : collé sous le header (pas de gap en haut)
  const firstCy = contentTop - half;

  // Nettoyage des anciens boutons mobiles éventuels
  if (persistentButtonPaths && persistentButtonPaths.length){
    for (const p of persistentButtonPaths){ targetState.delete(p); }
  }
  persistentButtonPaths = [];
  buttonCells.clear();

  const N = REQUIRED_BUTTONS; // 5
  for (let i = 0; i < N; i++){
    const onLeft = (i % 2 === 1);      // 0: droite, 1: gauche, 2: droite, ...
    const cx = onLeft ? xLeft : xRight;
    const cy = firstCy - i * stepY;

    const path = `btn/${i}`;
    targetState.set(path, {
      x: cx,
      y: cy,
      size: side - config.borderWidth,
      depth: 1,
      path,
      originalSize: side
    });

    const key = MOBILE_CATEGORY_ORDER[i % MOBILE_CATEGORY_ORDER.length];
    const cat = CATEGORIES.find(c => c.key === key);
    if (cat){
      buttonCells.set(path, { label: cat.label, url: cat.url, key: cat.key });
      persistentButtonPaths.push(path);
    }
  }

  // Hauteur totale : N * side + (N - 1) * gap (plus de gap supérieur)
  mobileWorldContentHeight = N * side + (N - 1) * gap;
  updateScrollDocHeight();

  return persistentButtonPaths.length >= REQUIRED_BUTTONS;
}



function ensureFallbackButtons(){
  // En mobile on retombe sur le layout déterministe
  if (isMobileBucket()){
    buildMobileButtonsDeterministic();
  }
  // Desktop / tablette : rien à faire, presetForBucket() couvre le cas.
}
  
  
// Layout helpers
function getLayoutMetrics(){
  const viewHeight = camera.top - camera.bottom;
  const viewWidth  = camera.right - camera.left;

  // largeur d’une case D1 en unités monde
  const w = viewWidth / baseCols;

  // *** Mesure DOM du header réel (pixels CSS) ***
  const headerEl = document.getElementById('ui-header');
  const headerPx = headerEl ? Math.round(headerEl.getBoundingClientRect().height) : 0;

  // conversion px -> monde
  const headerWorld = (headerPx / window.innerHeight) * viewHeight;

  // 1 px CSS en unités monde
  const onePxWorld = viewHeight / window.innerHeight;

  // Verrouille la gouttière à 1 px CSS
  if (Math.abs(config.borderWidth - onePxWorld) > 1e-6) {
    config.borderWidth = onePxWorld;
  }

  // ✅ Correction : on AJOUTE le scroll pour faire monter le contenu
  // (avant: camera.top - headerWorld - scrollOffsetWorld)
  const contentTop = camera.top - headerWorld + scrollOffsetWorld;

  return { viewHeight, viewWidth, w, menuHeight: headerWorld, contentTop, onePxWorld };
}



  function isFullyVisible(x, y, size, contentTop){
  const eps = config.borderWidth * 2;
  const half = size / 2;
  return (
    x - half >= camera.left + eps &&
    x + half <= camera.right - eps &&
    y - half >= camera.bottom + eps &&
    y + half <= contentTop - eps
  );
}
function isVisibleEnough(x, y, size, contentTop, minRatio = 0.5){
  const half = size / 2;
  const left   = Math.max(camera.left,   x - half);
  const right  = Math.min(camera.right,  x + half);
  const bottom = Math.max(camera.bottom, y - half);
  const top    = Math.min(contentTop,    y + half);
  const w = Math.max(0, right - left);
  const h = Math.max(0, top - bottom);
  const overlap = w * h;
  const full = size * size;
  return (overlap / full) >= minRatio;
}
function depth1SlotKey(x, y, w, contentTop){
  const cell = w;
  const col = Math.floor((x - camera.left) / cell);
  const row = Math.floor((contentTop - y) / cell);
  return `D1:${col},${row}`;
}

// THREE init
const canvas = document.createElement('canvas'); canvas.id = 'webgl-canvas'; document.body.appendChild(canvas);

(async () => { init(); await bootstrap(); animate(); })();

function init(){
  scene = new THREE.Scene(); scene.background = new THREE.Color(config.backgroundColor);
  const aspect = window.innerWidth / window.innerHeight; const height = 10; const width = height * aspect;
  camera = new THREE.OrthographicCamera(-width/2, width/2, height/2, -height/2, 1, 1000); camera.position.z = 10;
  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, canvas, powerPreference:'high-performance' });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));
  renderer.setSize(window.innerWidth, window.innerHeight);
  geometry = new THREE.PlaneGeometry(1,1);
  cursorMaterial = new THREE.MeshBasicMaterial({ color: config.cursorColor, transparent:true, opacity:0.85 });
  darkMaterial   = new THREE.MeshBasicMaterial({ color: config.darkColor });
  dotMaterial    = new THREE.MeshBasicMaterial({ color: config.dotColor, depthTest: false });
  menuBorderMaterial = new THREE.MeshBasicMaterial({ color: config.backgroundColor });
  mouseSquare = new THREE.Mesh(geometry, cursorMaterial); mouseSquare.userData.targetPosition = new THREE.Vector3(); mouseSquare.userData.targetScale = new THREE.Vector3(); mouseSquare.renderOrder = 4; scene.add(mouseSquare);
  cursorBorder = new THREE.Mesh(geometry, darkMaterial); cursorBorder.userData.targetPosition = new THREE.Vector3(); cursorBorder.userData.targetScale = new THREE.Vector3(); cursorBorder.renderOrder = 3; scene.add(cursorBorder);
  createGrainPlane(); createMenuPlane();
  menuBorderBottom.visible = false; // on laisse le 1px au CSS
  window.addEventListener('mousemove', onMouseMove, { passive:true });
  window.addEventListener('click', onClick, { passive:true });
  window.addEventListener('scroll', onScroll, { passive:true });
  // Curseur DOM par-dessus le menu
  
// ----- Animation hover pour les liens du menu [ABOUT] / [CONTACT] -----
function enableNavButtonHoverAnimation(){
  // gsap est chargé via <script ... defer>, s'il n'est pas prêt on retente au prochain frame
  if (typeof window.gsap === 'undefined') {
    requestAnimationFrame(enableNavButtonHoverAnimation);
    return;
  }
  const buttons = document.querySelectorAll('#nav-links .nav-btn');
  buttons.forEach(setupAnimatedNavButton);
}

function setupAnimatedNavButton(button){
  if (!button) return;

  // Récupère le texte original (ex: "[ ABOUT ]")
  const label = button.textContent.trim();

  // Construit le markup nécessaire à l'animation
  button.innerHTML = `
    <span class="text-container">
      <span class="button-text initial-text">${label}</span>
      <span class="button-text hover-text">${label}</span>
    </span>
  `;

  // Découpe un élément texte en <span class="letter">…</span>
  const splitTextIntoSpans = (el) => {
    const text = el.textContent;
    el.innerHTML = [...text].map(ch => `<span class="letter">${ch === ' ' ? '&nbsp;' : ch}</span>`).join('');
    return el.querySelectorAll('.letter');
  };

  const initialEl = button.querySelector('.initial-text');
  const hoverEl   = button.querySelector('.hover-text');

  const initialLetters = splitTextIntoSpans(initialEl);
  const hoverLetters   = splitTextIntoSpans(hoverEl);

  // Positionnements init
  gsap.set(hoverEl,       { position:'absolute', top:0, left:0 });
  gsap.set(initialLetters,{ y:'0%'    });
  gsap.set(hoverLetters,  { y:'100%'  });

  // Timeline par bouton
  const tl = gsap.timeline({ paused:true });
  tl.to(initialLetters, {
      y: '-100%',
      stagger: 0.015,
      duration: 0.20,
      ease: 'power2.inOut'
    })
    .to(hoverLetters, {
      y: '0%',
      stagger: 0.015,
      duration: 0.20,
      ease: 'power2.inOut'
    }, '<0.05');

  button.addEventListener('mouseenter', () => tl.play());
  button.addEventListener('mouseleave', () => tl.reverse());
}
  
  
(function createDomCursor(){
  const el = document.createElement('div');
  el.id = 'cursor-overlay';
  el.innerHTML = '<div class="inner"></div>';
  document.body.appendChild(el);
  domCursorEl = el;
})();
  
  enableNavButtonHoverAnimation();
  
  requestAnimationFrame(()=>{ updateMenuGeometry(); });
}

(function syncCssHeaderHeight(){
  const { menuHeight, viewHeight } = getLayoutMetrics();
  const menuHeightPx = Math.round((menuHeight / viewHeight) * window.innerHeight);
  document.documentElement.style.setProperty('--menu-h', menuHeightPx + 'px');
})();
  
async function bootstrap(){
  await scanLocalImages();
  const w = window.innerWidth, h = window.innerHeight;
  currentBucket = pickBucket(w, h);
  applyBucket();

  // 1) construit la grille et assigne ses images (gauche/droite)
  resetFractalRandom();

  // 2) maintenant que imageAssignment est rempli, l’overlay du milieu
  // peut piocher dans la même liste en évitant les doublons
  buildFreeOverlays();
}


function applyBucket(){
  const b = BUCKETS.find(x=>x.id===currentBucket);

  // Desktop / tablettes : on suit la grille du bucket
  if (currentBucket !== 'mobile-h' && currentBucket !== 'mobile-v'){
    if (config.baseColsOverride != null) {
      baseCols = Math.max(1, config.baseColsOverride);
      baseRowsPrimary = b?.grid.rows || 2;
    } else if (config.targetCellPx) {
      baseCols = Math.max(1, Math.round(window.innerWidth / config.targetCellPx));
      baseRowsPrimary = b?.grid.rows || 2;
    } else {
      baseCols = b?.grid.cols || 4;
      baseRowsPrimary = b?.grid.rows || 2;
    }
  } else {
    // Mobile : grille logique à 2 colonnes, le reste est géré par notre layout déterministe
    baseCols = 2;
    baseRowsPrimary = 2;
  }

  const wish = LAYOUT_WISH[currentBucket] || { wantD1:1, wantD2:4, buttonsOnD2:true };
  WANT_D1 = wish.wantD1;
  WANT_D2 = wish.wantD2;
  BUTTONS_ON_D2 = wish.buttonsOnD2;

  // ↓↓↓ NOUVEAU : profondeur max -1 en MOBILE (évite les plus petits carrés)
  if (currentBucket === 'mobile-h' || currentBucket === 'mobile-v') {
    TARGET_DEPTH = (prefersReducedMotion ? 4 : 6); // desktop: 5/7 → mobile: 4/6
  } else {
    TARGET_DEPTH = (prefersReducedMotion ? 5 : 7);
  }

  updateScrollDocHeight();
}


// Grain + Menu
function createGrainPlane(){
  const mat = new THREE.ShaderMaterial({
    transparent: true,
    uniforms: { uOpacity: { value: config.grainOpacity } },
    vertexShader: 'varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }',
    fragmentShader:'uniform float uOpacity; varying vec2 vUv; float r(vec2 st){ return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);} void main(){ vec2 uv=gl_FragCoord.xy/512.0; float g=r(uv); gl_FragColor=vec4(1.0,1.0,1.0,g*uOpacity); }'
  });
  grainPlane = new THREE.Mesh(new THREE.PlaneGeometry(1,1), mat);
  grainPlane.position.z = 1; grainPlane.renderOrder = 2; scene.add(grainPlane);
  updateGrainPlaneSize();
}
function createMenuPlane(){
  menuPlane = new THREE.Mesh(new THREE.PlaneGeometry(1,1), darkMaterial); menuPlane.position.z = 0.1; menuPlane.renderOrder = 0; scene.add(menuPlane);
  menuBorderBottom = new THREE.Mesh(new THREE.PlaneGeometry(1,1), menuBorderMaterial); menuBorderBottom.position.z = 0.11; menuBorderBottom.renderOrder = 1; scene.add(menuBorderBottom);
  updateMenuGeometry();
}
function updateMenuGeometry(){
  const { viewWidth, menuHeight } = getLayoutMetrics();
  menuPlane.scale.set(viewWidth, menuHeight, 1);
  menuPlane.position.set((camera.left + camera.right) / 2, camera.top - menuHeight / 2, 0.1);
}

function updateGrainPlaneSize(){ if(!grainPlane) return; const h=camera.top - camera.bottom; const w=camera.right - camera.left; grainPlane.scale.set(w, h, 1); }

// Resize (reload léger à la fin)
let resizeTimer=null;
window.addEventListener('resize', ()=>{
  const aspect = window.innerWidth / window.innerHeight; const height = 10; const width = height * aspect;
  camera.left=-width/2; camera.right=width/2; camera.top=height/2; camera.bottom=-height/2; camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  updateGrainPlaneSize(); updateMenuGeometry(); updateScrollDocHeight();
  if (resizeTimer) clearTimeout(resizeTimer);
  resizeTimer = setTimeout(()=>{ window.location.reload(); }, 250);
}, { passive:true });

// Hauteur de document + scroll
function updateScrollDocHeight(){
  const isMobile = (currentBucket === 'mobile-h' || currentBucket === 'mobile-v' || currentBucket === 'tablet-3:4' || currentBucket === 'tablet-9:16');
  const spacer = document.getElementById('scroll-spacer');
  if (!spacer) return;

  const { viewHeight, w, menuHeight } = getLayoutMetrics();

  let contentWorld;
  if (isMobile){
    // Utilise la hauteur calculée par le layout mobile déterministe (fallback si non calculée)
    contentWorld = mobileWorldContentHeight && mobileWorldContentHeight > 0
      ? mobileWorldContentHeight
      : Math.max(baseRowsPrimary, 5) * w;
  } else {
    const totalRows = baseRowsPrimary;
    contentWorld = totalRows * w;
  }

  const worldTotal = menuHeight + contentWorld;
  const docPx = Math.max(window.innerHeight, Math.ceil((worldTotal / viewHeight) * window.innerHeight));
  spacer.style.height = docPx + 'px';
}


function onScroll(){
  const isMobile = (currentBucket === 'mobile-h' || currentBucket === 'mobile-v' || currentBucket === 'tablet-3:4' || currentBucket === 'tablet-9:16');
  if (!isMobile){ scrollOffsetWorld = 0; return; }

  const { viewHeight, w, menuHeight } = getLayoutMetrics();
  const contentWorld = (mobileWorldContentHeight && mobileWorldContentHeight > 0)
    ? mobileWorldContentHeight
    : Math.max(baseRowsPrimary, 5) * w;

  const maxScrollPx = Math.max(0, document.documentElement.scrollHeight - window.innerHeight);
  const t = maxScrollPx > 0 ? window.scrollY / maxScrollPx : 0;

  const worldScrollable = Math.max(0, contentWorld - (viewHeight - menuHeight));
  scrollOffsetWorld = t * worldScrollable;

  needsBaseUpdate = true; // recalcule la grille pile sous le menu
}

// QuadTree / Build
function resetFractalRandom(){
  forceRecreateLabelsOnce = true;
  for (let tries=0; tries<50; tries++){
    reseed();
    targetState.clear(); imageCells.clear(); buttonCells.clear();
    imageAssignment.clear(); imageSlots.clear(); buttonSlots.clear();
    const ok = updateFractalBase(true);
    if (ok){
      syncStateToMeshes();
      needsBaseUpdate = false;
      return;
    }
  }
  ensureFallbackButtons();
  syncStateToMeshes();
  needsBaseUpdate = false;
}
function createQuadTree(x, y, size, depth, path, maxDepthOverride=-1){
  const noiseVal = (noise2D(x*config.noiseScale, y*config.noiseScale)+1)/2;

  // profondeur max locale pilotée par le bruit
  const baseMaxDepth =
    (maxDepthOverride !== -1)
      ? maxDepthOverride
      : (config.minDepth + Math.floor(noiseVal * config.maxDepthVariation));

  // ↓↓↓ NOUVEAU : en mobile on retire 1 niveau de profondeur max
  const regionalMaxDepth = (currentBucket === 'mobile-h' || currentBucket === 'mobile-v')
    ? Math.max(config.minDepth, baseMaxDepth - 1)
    : baseMaxDepth;

  const currentProbability = config.initialProbabilityToSubdivide - depth * config.depthDecayFactor;

  const stop =
    depth >= regionalMaxDepth ||
    (depth > 0 && Math.random() > currentProbability) ||
    size/2 <= config.borderWidth;

  if (stop){
    const scale = size - config.borderWidth;
    if (scale > 0) targetState.set(path, { x, y, size:scale, depth, path, originalSize:size });
    return;
  }

  const ns = size/2, o = size/4, d = depth+1;
  createQuadTree(x-o, y+o, ns, d, path+'/0', maxDepthOverride);
  createQuadTree(x+o, y+o, ns, d, path+'/1', maxDepthOverride);
  createQuadTree(x-o, y-o, ns, d, path+'/2', maxDepthOverride);
  createQuadTree(x+o, y-o, ns, d, path+'/3', maxDepthOverride);
}


// On conçoit le contenu sur 4 colonnes "virtuelles" (preset desktop-16:9)
// Colonnes "centrales" où w est interdit (Motion = col 1, Creative Coding = col 2)
const CONTENT_COLS = 4;
const NO_D1_CONTENT_COLS = new Set([1, 2]);
// plus AUCUNE exception : pas de D1 autorisé dans ces colonnes
const D1_EXCEPTIONS = new Set();

  
// Décalage horizontal (en colonnes) pour centrer CONTENT_COLS dans baseCols
function contentOffsetColsForBucket(){
  return Math.max(0, (baseCols - CONTENT_COLS) / 2); // 21:9 -> 0.5, 32:9 -> 1, etc.
}

// Ajoute des "filler" sur les côtés des rangées primaires.
// Ancrage sur la LIMITE INTÉRIEURE, génération vers l’extérieur.
// Si la bande fait w/2 (21:9), on tuile verticalement 2 carrés w/2.
// Ajoute des fillers latéraux en VRAIES cases D1 (largeur = w), alignées sur la grille contenu.
// Origine = bord gauche intérieur du contenu (offsetCols), on prolonge
// vers la GAUCHE (colonnes -1, -2, ...) et vers la DROITE (colonnes 4, 5, ...)
// jusqu'à recouvrir tout l'écran (on accepte le dépassement qui sera croppé).
function addPrimaryRowSideFillers(row, offsetCols){
  if (isMobileBucket()) return;

  const { w, contentTop } = getLayoutMetrics();
  const y = contentTop - row * w - w/2;  // centre de la rangée

  // Bords INTÉRIEURS du contenu (en monde)
  const innerLeftEdge  = camera.left + offsetCols * w;
  const innerRightEdge = camera.left + (offsetCols + CONTENT_COLS) * w;

  // --- FILLER GAUCHE : colonnes -1, -2, ... (centres à innerLeftEdge - (k+0.5)*w)
  {
    let i = 0;
    let x = innerLeftEdge - 0.5 * w;           // première colonne juste à gauche du contenu
    while (x + w/2 >= camera.left - 1e-6) {    // on continue tant que la case recouvre (ou dépasse) le bord gauche
      const p = `filler/L/${row}/${i++}`;
      createQuadTree(x, y, w, 1, p, -1);
      x -= w;                                   // on avance d'une colonne vers la gauche
    }
  }

  // --- FILLER DROITE : colonnes 4, 5, ... (centres à innerRightEdge + (k+0.5)*w)
  {
    let i = 0;
    let x = innerRightEdge + 0.5 * w;          // première colonne juste à droite du contenu
    while (x - w/2 <= camera.right + 1e-6) {   // on continue tant que la case recouvre (ou dépasse) le bord droit
      const p = `filler/R/${row}/${i++}`;
      createQuadTree(x, y, w, 1, p, -1);
      x += w;                                   // on avance d'une colonne vers la droite
    }
  }
}

function updateFractalBase(forceFull = false){
  // on repart de zéro à chaque build
  targetState.clear();

  const { w, contentTop } = getLayoutMetrics();
  const preset = presetForBucket(currentBucket);

  // S'il n'y a pas de preset on retombe sur le fallback de boutons
  if (!preset) {
    ensureFallbackButtons();
    return true;
  }

  // === 1) Construire la grille de base (content + fillers) ===
  const FORCE_D1 = new Set();
  (preset?.buttons  || []).forEach(b  => { FORCE_D1.add(`content/${b.row}/${b.col}`); });
  (preset?.imagesD1 || []).forEach(im => { FORCE_D1.add(`content/${im.row}/${im.col}`); });
  (preset?.imagesD2 || []).forEach(im => { FORCE_D1.add(`content/${im.row}/${im.col}`); });

  // En mobile on prévoit un minimum de lignes pour avoir de la matière autour,
  // mais on ne laissera rien passer sous les boutons (voir étape 4).
  const visibleRows = Math.ceil((contentTop - camera.bottom) / w);
  const minRows = (currentBucket === 'mobile-h' || currentBucket === 'mobile-v' || currentBucket === 'tablet-3:4' || currentBucket === 'tablet-9:16')
    ? Math.max(baseRowsPrimary, 5)
    : baseRowsPrimary;
  const totalRows = Math.max(minRows, visibleRows);

  const offsetCols = contentOffsetColsForBucket();

  for (let row = 0; row < totalRows; row++) {
    const isPrimary = row < baseRowsPrimary;
    const colsThisRow = isPrimary ? Math.min(CONTENT_COLS, baseCols) : baseCols;

    for (let col = 0; col < colsThisRow; col++) {
      const pref = isPrimary ? 'content' : 'filler';
      const path = `${pref}/${row}/${col}`;

      const x = camera.left + (col + 0.5 + (isPrimary ? offsetCols : 0)) * w;
      const y = contentTop - row * w - w/2;

      const forceThisCell = (pref === 'content') && FORCE_D1.has(path);
      // Desktop/tablette : profondeur “normale”.
      // Mobile : on ajustera juste après.
      createQuadTree(x, y, w, 1, path, forceThisCell ? 1 : -1);
    }

    if (isPrimary) addPrimaryRowSideFillers(row, offsetCols);
  }

  // === 2) Règles desktop/tablette (interdictions et quotas) ===
  if (!isMobileBucket()){
    enforceNoD1InColumns(NO_D1_CONTENT_COLS);
    if (baseCols > CONTENT_COLS) enforceNoD1InSideFillers();

    const requiredD2 = (BUTTONS_ON_D2 ? REQUIRED_BUTTONS : 0) + WANT_D2;
    const protectedD1Paths = new Set();
    (preset?.buttons  || []).forEach(b  => { if (b.size === 'D1') protectedD1Paths.add(`content/${b.row}/${b.col}`); });
    (preset?.imagesD1 || []).forEach(im => { protectedD1Paths.add(`content/${im.row}/${im.col}`); });
    ensureMinDepth2Cells(requiredD2, WANT_D1, protectedD1Paths);
  }

  // === 3) Pattern mobile (pas de D1 plein, on force au moins du D2) ===
  if (isMobileBucket()){
    forceMobilePattern(); // remplace les D1 visibles par 4 D2 sauf exceptions fixées
  }

  // === 4) Placer les boutons ===
  // - Desktop/tablette : via le preset
  // - Mobile : layout déterministe 'btn/*'
  const okButtons = chooseButtonsThenImages(forceFull);

  // ★★★ NOUVEAU : en mobile on supprime TOUTE tuile (content/filler)
  // qui recouvre la surface de l’un des boutons 'btn/*' → plus de grille derrière.
  if (okButtons && isMobileBucket()){
    cutOutUnderButtons();   // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  }

  // === 5) Raffinements d'ambiance (hors boutons/images) ===
  if (okButtons) sprinkleRefinements(isMobileBucket() ? 128 : 24);

  // Rappel des règles desktop si besoin (après raffinements)
  if (!isMobileBucket()){
    enforceNoD1InColumns(NO_D1_CONTENT_COLS);
  }

  return okButtons;
}




// Motif mobile : garde les D1 du preset et subdivise le reste en D2
function forceMobilePattern(){
  if (!isMobileBucket()) return;
  const { w, contentTop } = getLayoutMetrics();
  const preset = presetForBucket(currentBucket);
  const fixed = new Set(
    (preset?.buttons || [])
      .filter(b => b.size === 'D1')
      .map(b => `content/${b.row}/${b.col}`)
  );
  for (const [path, s] of Array.from(targetState.entries())){
    if (!path.startsWith('content/')) continue;
    if (!isVisibleEnough(s.x, s.y, s.originalSize, contentTop, 0.05)) continue;
    const isD1 = Math.abs(s.originalSize - w) < 1e-6;
    if (!isD1) continue;
    if (fixed.has(path)) continue;
    targetState.delete(path);
    const size = s.originalSize, ns = size/2, d = 2, o = size/4;
    const quads = [
      {x:s.x-o, y:s.y+o, suffix:'/0'},
      {x:s.x+o, y:s.y+o, suffix:'/1'},
      {x:s.x-o, y:s.y-o, suffix:'/2'},
      {x:s.x+o, y:s.y-o, suffix:'/3'},
    ];
    for (const q of quads){
      if (!isVisibleEnough(q.x, q.y, ns, contentTop, 0.05)) continue;
      const p = path + q.suffix;
      targetState.set(p, { x:q.x, y:q.y, size:ns - config.borderWidth, depth:d, path:p, originalSize:ns });
    }
  }
}

// Supprime toutes les tuiles de la grille qui passent sous les boutons mobiles
// Supprime uniquement les tuiles 100% sous les boutons, garde une "gouttière" 1px
function cutOutUnderButtons(keepGutterPx = 1){
  const { onePxWorld } = getLayoutMetrics();
  const guard = Math.max(keepGutterPx, 1) * onePxWorld; // ≈1px CSS en monde

  // Rectangles "intérieurs" des boutons (réduits de guard)
  const btnRects = [];
  for (const [path, s] of targetState.entries()){
    if (!path.startsWith('btn/')) continue;
    const innerHalf = (s.originalSize / 2) - guard; // anneau de sécurité
    btnRects.push({ x: s.x, y: s.y, half: innerHalf });
  }
  if (!btnRects.length) return;

  // Supprime seulement les tuiles complètement incluses dans l'un de ces inner rects
  for (const [path, s] of Array.from(targetState.entries())){
    if (path.startsWith('btn/')) continue;
    if (!(path.startsWith('content/') || path.startsWith('filler/'))) continue;

    const half   = s.originalSize / 2;
    const left   = s.x - half;
    const right  = s.x + half;
    const bottom = s.y - half;
    const top    = s.y + half;

    let fullyInside = false;
    for (const b of btnRects){
      if (left  >= b.x - b.half &&
          right <= b.x + b.half &&
          bottom>= b.y - b.half &&
          top   <= b.y + b.half){
        fullyInside = true; break;
      }
    }
    if (fullyInside) targetState.delete(path);
  }
}

  
  
// Force: pas de D1 (w) dans certaines colonnes de la grille "content"
function enforceNoD1InColumns(colsSet){
  const { w, contentTop } = getLayoutMetrics();
  const toSplit = [];

  for (const [path, s] of targetState.entries()){
    if (!path.startsWith('content/')) continue;

    // ne viser que les feuilles D1 "content/row/col"
    const m = path.match(/^content\/(\d+)\/(\d+)$/);
    if (!m) continue;

    const col = parseInt(m[2], 10);
    if (!colsSet.has(col)) continue;

    // uniquement les cases plein w qui sont assez visibles
    if (Math.abs(s.originalSize - w) > 1e-6) continue;
    if (!isVisibleEnough(s.x, s.y, s.originalSize, contentTop, 0.05)) continue;

    toSplit.push({ path, s });
  }

  // on remplace chaque D1 par ses 4 enfants D2
  for (const { path, s } of toSplit){
    targetState.delete(path);

    const size = s.originalSize;
    const ns = size / 2;
    const d  = 2;
    const o  = size / 4;

    const quads = [
      { x: s.x - o, y: s.y + o, suffix: '/0' },
      { x: s.x + o, y: s.y + o, suffix: '/1' },
      { x: s.x - o, y: s.y - o, suffix: '/2' },
      { x: s.x + o, y: s.y - o, suffix: '/3' },
    ];

    for (const q of quads){
      if (!isVisibleEnough(q.x, q.y, ns, contentTop, 0.05)) continue;
      const p = path + q.suffix;
      targetState.set(p, {
        x: q.x, y: q.y,
        size: ns - config.borderWidth,
        depth: d, path: p, originalSize: ns
      });
    }
  }
}



// Force: pas de D1 (w) dans les colonnes latérales "filler/L" et "filler/R"
function enforceNoD1InSideFillers(){
  const { w, contentTop } = getLayoutMetrics();
  const toSplit = [];

  for (const [path, s] of targetState.entries()){
    if (!path.startsWith('filler/')) continue;
    if (!/^filler\/[LR]\/\d+\/\d+$/.test(path)) continue; // uniquement les latérales créées par addPrimaryRowSideFillers
    if (Math.abs(s.originalSize - w) > 1e-6) continue;    // D1 seulement
    if (!isVisibleEnough(s.x, s.y, s.originalSize, contentTop, 0.05)) continue;
    toSplit.push({ path, s });
  }

  for (const { path, s } of toSplit){
    targetState.delete(path);
    const size = s.originalSize;
    const ns = size / 2;
    const d  = 2;
    const o  = size / 4;

    const quads = [
      { x: s.x - o, y: s.y + o, suffix: '/0' },
      { x: s.x + o, y: s.y + o, suffix: '/1' },
      { x: s.x - o, y: s.y - o, suffix: '/2' },
      { x: s.x + o, y: s.y - o, suffix: '/3' },
    ];

    for (const q of quads){
      if (!isVisibleEnough(q.x, q.y, ns, contentTop, 0.05)) continue;
      const p = path + q.suffix;
      targetState.set(p, {
        x: q.x, y: q.y,
        size: ns - config.borderWidth,
        depth: d, path: p, originalSize: ns
      });
    }
  }
}
  
function specToPath(spec, contentTop, w) {
  if (!spec) return null;
  if (spec.size === 'D1') {
    const p = `content/${spec.row}/${spec.col}`;
    const s = targetState.get(p);
    if (!s) return null;
    if (!isVisibleEnough(s.x, s.y, s.originalSize, contentTop, 0.4)) return null;
    return p;
  }
  if (spec.size === 'D2') {
    return ensureD2Path(spec.row, spec.col, spec.quad, contentTop, w);
  }
  return null;
}
  
// === garantir l'existence d'une D2 et renvoyer son path ===
function ensureD2Path(row, col, quad, contentTop, w){
  const parent = `content/${row}/${col}`;
  const child  = `${parent}/${quad}`;

  // déjà présent ?
  const sChild = targetState.get(child);
  if (sChild){
    if (!isVisibleEnough(sChild.x, sChild.y, sChild.originalSize, contentTop, 0.40)) return null;
    return child;
  }

  // sinon on part d'un D1 plein w et on le subdivise
  const s = targetState.get(parent);
  if (!s) return null;
  if (Math.abs(s.originalSize - w) > 1e-6) return null;            // pas un D1 plein w
  if (!isVisibleEnough(s.x, s.y, s.originalSize, contentTop, 0.05)) return null;

  targetState.delete(parent);
  const size = s.originalSize, ns = size/2, d = 2, o = size/4;
  const quads = [
    {x:s.x-o, y:s.y+o, suffix:'/0'},
    {x:s.x+o, y:s.y+o, suffix:'/1'},
    {x:s.x-o, y:s.y-o, suffix:'/2'},
    {x:s.x+o, y:s.y-o, suffix:'/3'},
  ];
  for (const q of quads){
    if (!isVisibleEnough(q.x, q.y, ns, contentTop, 0.05)) continue;
    const p = parent + q.suffix;
    targetState.set(p, { x:q.x, y:q.y, size:ns - config.borderWidth, depth:d, path:p, originalSize:ns });
  }

  const sNew = targetState.get(child);
  return (sNew && isVisibleEnough(sNew.x, sNew.y, sNew.originalSize, contentTop, 0.40)) ? child : null;
}


function chooseButtonsThenImages(forceFull){
  imageCells.clear();
  buttonCells.clear();
  imageSlots.clear();
  buttonSlots.clear();

  // Mobile : on construit les 5 boutons w/2 en diagonale, sans images dédiées
  if (isMobileBucket() && USE_MOBILE_DETERMINISTIC){
    return buildMobileButtonsDeterministic();
  }

  // Desktop / tablettes : logique existante basée sur les presets
  const { w, contentTop } = getLayoutMetrics();
  const preset = presetForBucket(currentBucket);

  persistentButtonPaths = [];
  for (const b of (preset?.buttons || [])) {
    const path = specToPath(b, contentTop, w);
    if (!path) continue;
    const cat = CATEGORIES.find(c => c.key === b.key);
    if (!cat) continue;
    buttonCells.set(path, { label: cat.label, url: cat.url, key: cat.key });
    persistentButtonPaths.push(path);
  }
  const requiredBtnCount = preset?.buttons?.length ?? REQUIRED_BUTTONS;
  if (persistentButtonPaths.length < requiredBtnCount) return false;

  for (const img of (preset?.imagesD1 || [])){
    const p = `content/${img.row}/${img.col}`;
    const s = targetState.get(p);
    if (s && isVisibleEnough(s.x, s.y, s.originalSize, contentTop, 0.4) && !buttonCells.has(p)){
      imageCells.add(p);
    }
  }
  for (const spec of (preset?.imagesD2 || [])){
    const path = specToPath(spec, contentTop, w);
    if (path && !buttonCells.has(path)) imageCells.add(path);
  }

  const cells = Array.from(imageCells);
  let urlsToUse = [];
  if (forceFull || !persistentImageUrls || persistentImageUrls.length === 0){
    let uniqueUrls = Array.from(new Set(imageTextures));
    for (let i = uniqueUrls.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [uniqueUrls[i], uniqueUrls[j]] = [uniqueUrls[j], uniqueUrls[i]];
    }
    if (uniqueUrls.length === 0) uniqueUrls = ['img/logo-sooxy-art.png'];
    for (let i = 0; i < cells.length; i++) urlsToUse.push(uniqueUrls[i % uniqueUrls.length]);
    persistentImageUrls = urlsToUse.slice();
  } else {
    for (let i = 0; i < cells.length; i++) urlsToUse.push(persistentImageUrls[i % persistentImageUrls.length]);
  }
  for (let i = 0; i < cells.length; i++) imageAssignment.set(cells[i], urlsToUse[i]);
  for (const k of Array.from(imageAssignment.keys())) if (!imageCells.has(k)) imageAssignment.delete(k);

  return true;
}


function chooseMobileAsciiButtonsAndImages(forceFull){
  const { w, contentTop } = getLayoutMetrics();

  // 1) Trouver les D2 "parents" des blocs 2x2 de B (boutons)
  const blocks = findMobileCategoryBlocksD3(); // => {d1row,d1col,quad2}[]
  const buttonD2Keys = new Set();
  blocks.forEach(b=>{
    const p = `content/${b.d1row}/${b.d1col}`;
    // on s’assure que la D1 existe et est visible
    const s = targetState.get(p);
    if (!s || !isVisibleEnough(s.x, s.y, s.originalSize, contentTop, 0.40)) return;
    // la D2 fille
    buttonD2Keys.add(`${p}/${b.quad2}`);
  });

  // 2) Subdiviser TOUTES les D1 "content/row/col" en D2
  const toSplitD1 = [];
  for (const [path, s] of targetState.entries()){
    if (!/^content\/\d+\/\d+$/.test(path)) continue; // D1 seulement
    if (!isVisibleEnough(s.x, s.y, s.originalSize, contentTop, 0.05)) continue;
    toSplitD1.push({ path, s });
  }
  for (const {path, s} of toSplitD1){
    targetState.delete(path);
    const size = s.originalSize, ns = size/2, d = 2, o = size/4;
    const quads = [
      {x:s.x-o, y:s.y+o, suffix:'/0'},
      {x:s.x+o, y:s.y+o, suffix:'/1'},
      {x:s.x-o, y:s.y-o, suffix:'/2'},
      {x:s.x+o, y:s.y-o, suffix:'/3'},
    ];
    for (const q of quads){
      if (!isVisibleEnough(q.x, q.y, ns, contentTop, 0.05)) continue;
      const p = path + q.suffix;
      targetState.set(p, { x:q.x, y:q.y, size:ns - config.borderWidth, depth:d, path:p, originalSize:ns });
    }
  }

  // 3) Parcourir les D2 : garder celles marquées "bouton", subdiviser les autres en D3
  persistentButtonPaths = [];
  buttonCells.clear();
  imageCells.clear();
  imageSlots.clear();
  buttonSlots.clear();

  const d2List = [];
  for (const [path, s] of targetState.entries()){
    if (!/^content\/\d+\/\d+\/[0-3]$/.test(path)) continue; // D2
    if (!isVisibleEnough(s.x, s.y, s.originalSize, contentTop, 0.05)) continue;
    d2List.push({ path, s });
  }

  // Tri stable (lecture haut->bas, gauche->droite)
  d2List.sort((a,b)=> a.s.y===b.s.y ? a.s.x - b.s.x : b.s.y - a.s.y);

  // Pour attribution des catégories
  let catIdx = 0;

  for (const {path, s} of d2List){
    if (buttonD2Keys.has(path)){
      // garder la D2 telle quelle → bouton + image
      const key = MOBILE_CATEGORY_ORDER[catIdx % MOBILE_CATEGORY_ORDER.length];
      catIdx++;
      const cat = CATEGORIES.find(c => c.key === key);
      if (cat){
        buttonCells.set(path, { label: cat.label, url: cat.url, key: cat.key });
        persistentButtonPaths.push(path);
        imageCells.add(path); // même tuile porte l'image
      }
    } else {
      // subdiviser en D3 (4 petits carrés A w/4)
      targetState.delete(path);
      const size = s.originalSize, ns = size/2, d = 3, o = size/4;
      const quads = [
        {x:s.x-o, y:s.y+o, suffix:'/0'},
        {x:s.x+o, y:s.y+o, suffix:'/1'},
        {x:s.x-o, y:s.y-o, suffix:'/2'},
        {x:s.x+o, y:s.y-o, suffix:'/3'},
      ];
      for (const q of quads){
        if (!isVisibleEnough(q.x, q.y, ns, contentTop, 0.05)) continue;
        const p = path + q.suffix;
        targetState.set(p, { x:q.x, y:q.y, size:ns - config.borderWidth, depth:d, path:p, originalSize:ns });
      }
    }
  }

  // 4) Attribution images : 1 image par bouton D2
  const cells = Array.from(imageCells);
  let urlsToUse = [];
  if (forceFull || !persistentImageUrls || persistentImageUrls.length === 0){
    let uniqueUrls = Array.from(new Set(imageTextures));
    for (let i = uniqueUrls.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [uniqueUrls[i], uniqueUrls[j]] = [uniqueUrls[j], uniqueUrls[i]];
    }
    if (uniqueUrls.length === 0) uniqueUrls = ['img/logo-sooxy-art.png'];
    for (let i = 0; i < cells.length; i++) urlsToUse.push(uniqueUrls[i % uniqueUrls.length]);
    persistentImageUrls = urlsToUse.slice();
  } else {
    for (let i = 0; i < cells.length; i++) urlsToUse.push(persistentImageUrls[i % persistentImageUrls.length]);
  }
  for (let i = 0; i < cells.length; i++) imageAssignment.set(cells[i], urlsToUse[i]);

  // Nettoyage des images orphelines
  for (const k of Array.from(imageAssignment.keys())){
    if (!imageCells.has(k)) imageAssignment.delete(k);
  }

  // On veut au moins 5 boutons
  return persistentButtonPaths.length >= REQUIRED_BUTTONS;
}

function reformGridKeepImages(){
  // on garde persistentImageUrls tel quel
  forceRecreateLabelsOnce = true; // reconstruire proprement les labels DOM
  reseed();                      // nouveau bruit / seed => nouveau quad-tree

  targetState.clear();
  imageCells.clear();
  buttonCells.clear();
  imageAssignment.clear(); // on ré-attribuera les mêmes URLs aux nouvelles cases
  imageSlots.clear();
  buttonSlots.clear();

  const ok = updateFractalBase(false); // false => garde persistentImageUrls
  if (ok) {
    syncStateToMeshes();
  }
}  

function ensureMinDepth2Cells(required, preserveD1Count, protectedD1Paths = new Set()){
  const { w, contentTop } = getLayoutMetrics();
  let d1 = [], d2 = [];

  for (const [path, s] of targetState.entries()){
    if (!path.startsWith('content/')) continue;
    if (!isFullyVisible(s.x, s.y, s.originalSize, contentTop)) continue;

    // D1 visibles non protégées → candidates à subdiviser
    if (Math.abs(s.originalSize - w) < 1e-6){
      if (!protectedD1Paths.has(path)) d1.push({ path, s });
    }
    // D2 déjà présentes
    if (Math.abs(s.originalSize - w/2) < 1e-6){
      d2.push({ path, s });
    }
  }

  if (d2.length >= required) return;

  d1.sort((a,b)=> hashCode(a.path) - hashCode(b.path));
  let remainingD1 = d1.length;

  for (const {path, s} of d1){
    if (d2.length >= required) break;
    if ((remainingD1 - 1) < preserveD1Count) break;

    targetState.delete(path); remainingD1--;

    const size = s.originalSize, ns = size/2, d = 2, o = size/4;
    const quads = [
      {x:s.x-o, y:s.y+o, suffix:'/0'},
      {x:s.x+o, y:s.y+o, suffix:'/1'},
      {x:s.x-o, y:s.y-o, suffix:'/2'},
      {x:s.x+o, y:s.y-o, suffix:'/3'},
    ];
    for (const q of quads){
      if (!isVisibleEnough(q.x, q.y, ns, contentTop, 0.05)) continue;
      const p = path + q.suffix;
      targetState.set(p, { x:q.x, y:q.y, size:ns - config.borderWidth, depth:d, path:p, originalSize:ns });
      d2.push({ path:p, s:targetState.get(p) });
      if (d2.length >= required) break;
    }
  }
}

// Raffinements d’ambiance
// Raffinements d’ambiance — les D2 (w/2) “content” libres ont une chance d’être raffinés
function sprinkleRefinements(maxOps = 24){
  const { w, contentTop } = getLayoutMetrics();

  // subdiviser 1 feuille en 4
  const refineOnce = (it) => {
    targetState.delete(it.path);
    const { x, y, originalSize: os, depth: d, path: p } = it.s;
    const ns = os/2, nd = d+1, o = os/4;
    createQuadTree(x-o, y+o, ns, nd, p+'/0', -1);
    createQuadTree(x+o, y+o, ns, nd, p+'/1', -1);
    createQuadTree(x-o, y-o, ns, nd, p+'/2', -1);
    createQuadTree(x+o, y-o, ns, nd, p+'/3', -1);
  };

  let ops = 0;

  // -------- PASS 1 : D2 “content” libres, au hasard (peuvent rester tels quels) --------
  const front = [];
  for (const [path, s] of targetState.entries()){
    if (!path.startsWith('content/')) continue;
    if (imageCells.has(path) || buttonCells.has(path)) continue;
    if (Math.abs(s.originalSize - w/2) < 1e-6 &&              // cibles = D2 (w/2)
        isVisibleEnough(s.x, s.y, s.originalSize, contentTop, 0.05) &&
        s.depth < TARGET_DEPTH){
      front.push({ path, s });
    }
  }
  const saltFront = sessionSalt ^ 0x5151;
  front.sort((a,b)=> saltedKey(a.path, saltFront) - saltedKey(b.path, saltFront));

  for (const it of front){
    if (ops >= maxOps) break;
    // tirage aléatoire : ce D2 peut être laissé tel quel
    if (Math.random() < (config.refineChanceD2 ?? 0.5)){
      refineOnce(it); ops++;

      // parfois un petit raffinement en plus dans un des 4 enfants
      if (ops < maxOps && Math.random() < (config.extraChildChanceAfterD2 ?? 0.0)){
        const childIdx = Math.floor(Math.random() * 4);
        const childPath = it.path + '/' + childIdx;
        const child = targetState.get(childPath);
        if (child && child.depth < TARGET_DEPTH && !imageCells.has(childPath) && !buttonCells.has(childPath)){
          refineOnce({ path: childPath, s: child }); ops++;
        }
      }
    }
  }

  // -------- PASS 2 : ambiance générale (budget restant) --------
  if (ops >= maxOps) return;

  const candidates = [];
  for (const [path, s] of targetState.entries()){
    if (!isMobileBucket() && !(path.startsWith('content/') || path.startsWith('filler/'))) continue;
    if (imageCells.has(path) || buttonCells.has(path)) continue;
    if (s.depth >= TARGET_DEPTH) continue;
    candidates.push({ path, s });
  }

  const salt = sessionSalt ^ 0xABCDEF;
  candidates.sort((a,b)=> saltedKey(a.path, salt) - saltedKey(b.path, salt));

  for (const it of candidates){
    if (ops >= maxOps) break;
    refineOnce(it); ops++;
  }
}

// Materials
function getImageMaterial(url){
  // placeholder gris quand pas d'URL, ou si le chargement échoue
  const PLACEHOLDER_KEY = '__placeholder__';
  const getPlaceholder = () => {
    if (!materialCache.has(PLACEHOLDER_KEY)) {
      materialCache.set(PLACEHOLDER_KEY, new THREE.MeshBasicMaterial({ color: new THREE.Color(COLORS.placeholder) }));
    }
    return materialCache.get(PLACEHOLDER_KEY);
  };

  if (!url) return getPlaceholder();

  if (materialCache.has(url)) return materialCache.get(url);

  const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, map: null });
  textureLoader.load(url, tex=>{
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
    mat.map = tex; mat.needsUpdate = true;
  }, undefined, ()=>{
    mat.map = null; mat.color.set(COLORS.placeholder); // gris si erreur
    mat.needsUpdate = true;
  });

  materialCache.set(url, mat);
  return mat;
}
  
// --- Overlays libres + gouttières 1px (traits bleus) -----------------------
// Chaque overlay peut demander des "gutters" (left/right/top/bottom)
// qui sont des bandes de 1px CSS couleur fond, rendues AU-DESSUS de l'image.

const FREE_OVERLAYS = [
  {
    row: 1,
    col: 2,
    offsetCols: -0.5,
    offsetRows: 0,
    wMul: 1,
    hMul: 1,
    url: null, // auto: prendra dans imageTextures (BY-pics), en évitant si possible une image déjà utilisée
    gutters: { left: true, right: true, top: false, bottom: false }
  },
];


let freeOverlays = [];

function pickOverlayUrl() {
  // images déjà utilisées par la grille (D1 & D2)
  const used = new Set(imageAssignment.values());
  // on essaie de prendre une image de la même liste non encore utilisée
  for (const u of imageTextures) {
    if (!used.has(u)) return u;
  }
  // fallback si tout est utilisé ou liste vide
  return imageTextures[0] || 'img/logo-sooxy-art.png';
}

  
function buildFreeOverlays(){
  if (isMobileBucket()){
    // nettoie d'éventuels overlays déjà créés
    for (const o of freeOverlays){
      scene.remove(o.mesh);
      if (o.vLeft)   scene.remove(o.vLeft);
      if (o.vRight)  scene.remove(o.vRight);
      if (o.hTop)    scene.remove(o.hTop);
      if (o.hBottom) scene.remove(o.hBottom);
      if (o.cover)   scene.remove(o.cover);
    }
    freeOverlays.length = 0;
    return; // pas d'overlay en mobile
  }
 
  // Création
  for (const spec of FREE_OVERLAYS){
    // → même pool que la grille, et on évite si possible une image déjà utilisée
    const urlToUse = spec.url ? spec.url : pickOverlayUrl();
    const mat = getImageMaterial(urlToUse);

    const mesh = new THREE.Mesh(geometry, mat);
    mesh.renderOrder = 2;
    // on démarre "collapsé"
    mesh.position.set(0, 0, 0.20);
    mesh.scale.set(0, 0, 1);
    scene.add(mesh);

    // cache bleu sous l'image
    const cover = new THREE.Mesh(geometry, menuBorderMaterial);
    cover.renderOrder = 2;
    cover.position.set(0, 0, 0.19);
    cover.scale.set(0, 0, 1);
    scene.add(cover);

    // bandes 1px (fond bleu) au-dessus de l'image
    const makeStripe = () => {
      const m = new THREE.Mesh(geometry, menuBorderMaterial);
      m.renderOrder = 3;
      m.position.set(0, 0, 0.21);
      m.scale.set(0, 0, 1);
      m._tPos   = new THREE.Vector3();  // cibles pour lerp
      m._tScale = new THREE.Vector3();
      scene.add(m);
      return m;
    };

    const vLeft   = spec.gutters?.left   ? makeStripe() : null;
    const vRight  = spec.gutters?.right  ? makeStripe() : null;
    const hTop    = spec.gutters?.top    ? makeStripe() : null;
    const hBottom = spec.gutters?.bottom ? makeStripe() : null;

    const targetPosition = new THREE.Vector3();
    const targetScale    = new THREE.Vector3(0, 0, 1);

    freeOverlays.push({ mesh, spec, vLeft, vRight, hTop, hBottom, targetPosition, targetScale, cover });
  }

  // Calcule les cibles (centre + tailles)
  updateFreeOverlays();

  // Snap initial: image = au bon centre, scale 0 (anim ensuite)
  for (const o of freeOverlays){
    o.mesh.position.copy(o.targetPosition);
    o.mesh.scale.set(0, 0, 1);

    if (o.cover){
      o.cover.position.set(o.targetPosition.x, o.targetPosition.y, 0.19);
    }

    if (o.vLeft){
      o.vLeft.position.copy(o.vLeft._tPos);
      o.vLeft.scale.set(o.vLeft._tScale.x, 0, 1);
    }
    if (o.vRight){
      o.vRight.position.copy(o.vRight._tPos);
      o.vRight.scale.set(o.vRight._tScale.x, 0, 1);
    }
    if (o.hTop){
      o.hTop.position.copy(o.hTop._tPos);
      o.hTop.scale.set(0, o.hTop._tScale.y, 1);
    }
    if (o.hBottom){
      o.hBottom.position.copy(o.hBottom._tPos);
      o.hBottom.scale.set(0, o.hBottom._tScale.y, 1);
    }
  }
}





function updateFreeOverlays(){
  if (!freeOverlays.length) return;

  const { w, contentTop } = getLayoutMetrics();
  const bucketOffset = contentOffsetColsForBucket();

  for (const o of freeOverlays){
    const { spec } = o;

    const colNudge = spec.offsetCols || 0;
    const rowNudge = spec.offsetRows || 0;

    const cx = camera.left + (spec.col + 0.5 + bucketOffset + colNudge) * w;
    const cy = contentTop   - (spec.row + 0.5 + rowNudge) * w;
    const sx = w * (spec.wMul || 1);
    const sy = w * (spec.hMul || 1);

    // → cibles d’anim de l’image overlay
    o.targetPosition.set(cx, cy, 0.20);
    o.targetScale.set(
      Math.max(0, sx - config.borderWidth),
      Math.max(0, sy - config.borderWidth),
      1
    );

    // cibles des traits 1px
    const leftX   = cx - sx/2;
    const rightX  = cx + sx/2;
    const topY    = cy + sy/2;
    const bottomY = cy - sy/2;
    const bw = config.borderWidth;

    if (o.vLeft){   o.vLeft._tPos.set(leftX,  cy, 0.21);   o.vLeft._tScale.set(bw,     sy + bw, 1); }
    if (o.vRight){  o.vRight._tPos.set(rightX, cy, 0.21);  o.vRight._tScale.set(bw,     sy + bw, 1); }
    if (o.hTop){    o.hTop._tPos.set(cx,    topY, 0.21);   o.hTop._tScale.set(sx + bw, bw,     1); }
    if (o.hBottom){ o.hBottom._tPos.set(cx, bottomY, 0.21);o.hBottom._tScale.set(sx + bw, bw,     1); }

    // --- cache bleu : taille finale dès le 1er frame (pas d'anim) ---
    if (o.cover){
      o.cover.position.set(cx, cy, 0.19);
      o.cover.scale.set(sx + bw*2, sy + bw*2, 1);
    }
  }
}


  

function makeTopRightLabelSprite(text, squareSize){
  const lines = text.split('\\n');
  const cvs = document.createElement('canvas'); const W=1024, H=768;
  cvs.width = W; cvs.height = H;
  const ctx = cvs.getContext('2d');
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = COLORS.textCSS;
  ctx.textBaseline = 'top'; ctx.textAlign = 'right';
  const fontPx = Math.floor(H * 0.11);
  ctx.font = `700 ${fontPx}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace`;
  const margin = Math.floor(H * 0.08); const lineGap = Math.floor(fontPx * 0.12);
  let y = margin; for (const line of lines){ ctx.fillText(line, W - margin, y); y += fontPx + lineGap; }
  const tex = new THREE.CanvasTexture(cvs); tex.colorSpace = THREE.SRGBColorSpace;
  const sprMat = new THREE.SpriteMaterial({ map: tex, depthTest:false, depthWrite:false, transparent:true, color: new THREE.Color(COLORS.textCSS) });
  const spr = new THREE.Sprite(sprMat); const aspect = H/W; spr.scale.set(squareSize, squareSize*aspect, 1); spr.center.set(1,1); spr.renderOrder = 6; return spr;
}

let forceRecreateLabelsOnce = false;

function destroyDomLabel(st){
  if (st.baffles){ st.baffles.forEach(b=>b.stop()); st.baffles = null; }
  if (st.domLabelEl){ st.domLabelEl.remove(); st.domLabelEl = null; }
}

function rebuildDomLabel(st, label){
  destroyDomLabel(st);
  const el = makeDomLabelEl(label);
  document.getElementById('labels-layer')?.appendChild(el);
  st.domLabelEl = el;
  st.labelText = label; // garde le texte courant

  if (window.baffle){
    const lines = Array.from(el.querySelectorAll('.line'));
    const speed = Math.max(1, (config.labelBaffleSpeedMs|0) || 1);
    st.baffles = lines.map(line =>
      window.baffle(line).set({ characters:'!/|~#.^+*$#%sooxy', speed })
    );
  }
}

  
// Sync meshes
function syncStateToMeshes(){
  const newKeys = new Set(targetState.keys());

  // 1) Retirer ce qui n'existe plus
  for (const [key, st] of Array.from(fractalState.entries())){
    if (!newKeys.has(key)) {
      st.targetScale.set(0,0,0);
      if (st.dotMesh) st.dotMesh.scale.set(0,0,0);
      if (st.labelSprite) { scene.remove(st.labelSprite); st.labelSprite = null; }
      destroyDomLabel(st);
      forceRecreateLabelsOnce = false;  // on a tout reconstruit pour ce cycle
    }
  }

  // 2) Créer/mettre à jour ce qui doit exister
  for (const key of newKeys){
    const t   = targetState.get(key);
    const ex  = fractalState.get(key);
    const isImg = imageCells.has(key);
    const isBtn = buttonCells.has(key);

    let material = darkMaterial;
    if (isImg) {
      const url = imageAssignment.get(key);
      material  = getImageMaterial(url);
    }


    if (ex){
      // --- UPDATE ---
      ex.targetPosition.set(t.x, t.y, 0);
      ex.targetScale.set(t.size, t.size, 1);
      if (ex.mesh.material !== material) ex.mesh.material = material;
      ex.isButton = isBtn; ex.isImage = isImg;
      ex.mesh.renderOrder = isBtn ? 3 : 0;   // boutons devant la grille
      if (!isImg && config.showDots && !ex.dotMesh) addDotToState(ex);

      // labels DOM + baffle (robuste au reset)
      if (isBtn){
        const label = buttonCells.get(key)?.label || '';
        if (!ex.domLabelEl || ex.labelText !== label || forceRecreateLabelsOnce){
          rebuildDomLabel(ex, label);  // ← recrée proprement spans + baffle
        }
      } else {
        destroyDomLabel(ex);
      }


    } else {
      // --- CREATION ---
      const mesh = meshPool.pop() || new THREE.Mesh(geometry);
      mesh.material = material;
      mesh.position.set(t.x, t.y, 0);
      mesh.scale.set(0, 0, 0);
      mesh.renderOrder = isBtn ? 3 : 0;
      scene.add(mesh);

      const st = {
        mesh,
        dotMesh: null,
        labelSprite: null,         // ancien système, gardé à null
        domLabelEl: null,
        baffles: null,
        hovering: false,
        targetPosition: new THREE.Vector3(t.x, t.y, 0),
        targetScale:    new THREE.Vector3(t.size, t.size, 1),
        originalSize:   t.originalSize,
        isButton: isBtn,
        isImage:  isImg
      };
      fractalState.set(key, st);

      if (!isImg && config.showDots) addDotToState(st);

      if (isBtn){
        const label = buttonCells.get(key)?.label || '';
        rebuildDomLabel(st, label);
      }

    }
  }
}

function getDotScale(state){
  // ✅ Mobile : point fixe de 3 px
  if (isMobileBucket()) {
    const { onePxWorld } = getLayoutMetrics(); // 1 px CSS en unités "monde"
    return 1.5 * onePxWorld;
  }

  // 🖥️ Desktop / tablette : on garde ton comportement actuel
  const cappedDotSize = Math.min(0.5, config.dotSize);
  if (config.dotSizeIsRelative) return state.mesh.scale.x * cappedDotSize;
  const viewHeight = camera.top - camera.bottom;
  const viewWidth  = camera.right - camera.left;
  const gridSize   = Math.max(viewWidth, viewHeight);
  return (gridSize / 256) * cappedDotSize;
}

function addDotToState(st){
  if (st.dotMesh) return;
  st.dotMesh = dotMeshPool.pop() || new THREE.Mesh(geometry, dotMaterial);
  st.dotMesh.position.copy(st.mesh.position);
  st.dotMesh.position.z = 0.02;  // au-dessus des cases
  st.dotMesh.renderOrder = 1;    // devant les cases, sous les overlays
  scene.add(st.dotMesh);
  const sc = getDotScale(st);
  st.dotMesh.scale.set(sc, sc, 1);
}

// Anim
// Remplace toute ta fonction animate() par celle-ci
function animate(){
  requestAnimationFrame(animate);

  if (needsBaseUpdate){ 
    const ok = updateFractalBase(false);
    if (ok) { syncStateToMeshes(); }
    needsBaseUpdate = false;
  }

  if (needsRefineCheck){
    const wp = new THREE.Vector3(lastMouseScreenPos.x, lastMouseScreenPos.y, 0).unproject(camera);
    if (refineTargetStateAt(wp)) syncStateToMeshes();
    updateMouseSquareTarget(wp);
    needsRefineCheck = false;
  }

  // curseur carré (canvas)
  mouseSquare.position.lerp(mouseSquare.userData.targetPosition, config.mouseSquareAnimationSpeed);
  mouseSquare.scale.lerp(mouseSquare.userData.targetScale, config.mouseSquareAnimationSpeed);
  cursorBorder.position.lerp(cursorBorder.userData.targetPosition, config.mouseSquareAnimationSpeed);
  cursorBorder.scale.lerp(cursorBorder.userData.targetScale, config.mouseSquareAnimationSpeed);

  // animer les tuiles
  for (const [key, st] of Array.from(fractalState.entries())){
    if (st.isButton) {
      // boutons : pas de lerp (snap)
      st.mesh.position.copy(st.targetPosition);
      st.mesh.scale.copy(st.targetScale);
      if (st.labelSprite){
        const m = st.targetScale.x * 0.03;
        st.labelSprite.position.set(
          st.targetPosition.x + (st.targetScale.x/2 - m),
          st.targetPosition.y + (st.targetScale.x/2 - m),
          0.2
        );
        st.labelSprite.scale.set(st.targetScale.x, st.targetScale.x*0.75, 1);
      }
    } else {
      // reste de la grille : lerp doux
      st.mesh.position.lerp(st.targetPosition, config.gridAnimationSpeed);
      st.mesh.scale.lerp(st.targetScale, config.gridAnimationSpeed);
    }

    // >>> BLOC LABELS DOM — VERSION CORRIGÉE (UNIQUE) <<<
    if (st.isButton && st.domLabelEl){
      const { w, contentTop } = getLayoutMetrics();

      // marges internes (en "monde")
      const btnSide = st.mesh.scale.x; // côté réel du bouton (déjà "snap")
      const mRightWorld = btnSide * LABEL_MARGIN_PCT_RIGHT;
      const mTopWorld   = btnSide * LABEL_MARGIN_PCT_TOP;


      const half = st.mesh.scale.x / 2;

      // ancre haut-droite de la tuile
      const tx = st.mesh.position.x + half - mRightWorld;
      let   ty = st.mesh.position.y + half - mTopWorld;

      // ne pas dépasser le top du contenu
      ty = Math.min(ty, contentTop - mTopWorld);

      // monde -> pixels
      const p = worldToClientXY(new THREE.Vector3(tx, ty, 0));
      const pxPerWorldX = window.innerWidth  / (camera.right - camera.left);
      const boxWidthPx  = Math.max(0, (st.mesh.scale.x - 2 * mRightWorld) * pxPerWorldX);

    // clamp "anti-chevauchement header" : top >= (headerBottom + SAFE_TOP_GAP_PX)
      const contentTopPx = worldToClientXY(new THREE.Vector3(0, contentTop, 0)).y;
      const minTopPx     = contentTopPx + SAFE_TOP_GAP_PX;
      const finalTopPx   = Math.max(p.y, minTopPx);

      // placement + sizing
      st.domLabelEl.style.left     = p.x + 'px';
      st.domLabelEl.style.top      = (finalTopPx + LABEL_NUDGE_PX_Y) + 'px';
      st.domLabelEl.style.width    = boxWidthPx + 'px';
      st.domLabelEl.style.fontSize = Math.max(12, st.mesh.scale.x * pxPerWorldX * 0.1) + 'px';

      // hover précis (pas de parallaxe)
      const wp = new THREE.Vector3(lastMouseScreenPos.x, lastMouseScreenPos.y, 0).unproject(camera);
      const inside = (
        wp.x >= st.mesh.position.x - half && wp.x <= st.mesh.position.x + half &&
        wp.y >= st.mesh.position.y - half && wp.y <= st.mesh.position.y + half
      );

      st.domLabelEl.style.color = inside ? '#f3ff00' : '#f3f1ee';

      if (inside && !st.hovering){
        st.hovering = true;
        if (st.baffles){
          st.baffles.forEach(b=>{
            b.start();
            b.reveal(Math.max(0, (config.labelRevealMs|0)));
          });
        }
      }
      if (!inside) st.hovering = false;
    }
    // >>> FIN BLOC LABELS DOM <<<


    // point brillant central (option)
    if (st.dotMesh){
      st.dotMesh.position.copy(st.mesh.position);
      st.dotMesh.position.z = 0.02;
      const sc = getDotScale(st);
      if (st.isImage) st.dotMesh.scale.set(0, 0, 0);
      else            st.dotMesh.scale.set(sc, sc, 1);
    }

    // retrait des tuiles disparues
    if (st.mesh.scale.x < 0.001 && st.targetScale.x === 0){
      scene.remove(st.mesh); meshPool.push(st.mesh);
      if (st.dotMesh){ scene.remove(st.dotMesh); dotMeshPool.push(st.dotMesh); }
      if (st.labelSprite){ scene.remove(st.labelSprite); }
      if (st.domLabelEl){ st.domLabelEl.remove(); st.domLabelEl = null; }
      if (st.baffles){ st.baffles.forEach(b=>b.stop()); st.baffles = null; }
      fractalState.delete(key);
    }
  }

  // MAJ overlays libres + gouttières (1px)
  updateFreeOverlays();
  for (const o of freeOverlays){
    o.mesh.position.lerp(o.targetPosition, config.gridAnimationSpeed);
    o.mesh.scale.lerp(o.targetScale,       config.gridAnimationSpeed);

    if (o.vLeft){
      o.vLeft.position.lerp(o.vLeft._tPos,   config.gridAnimationSpeed);
      o.vLeft.scale.lerp(   o.vLeft._tScale, config.gridAnimationSpeed);
    }
    if (o.vRight){
      o.vRight.position.lerp(o.vRight._tPos,   config.gridAnimationSpeed);
      o.vRight.scale.lerp(   o.vRight._tScale, config.gridAnimationSpeed);
    }
    if (o.hTop){
      o.hTop.position.lerp(o.hTop._tPos,   config.gridAnimationSpeed);
      o.hTop.scale.lerp(   o.hTop._tScale, config.gridAnimationSpeed);
    }
    if (o.hBottom){
      o.hBottom.position.lerp(o.hBottom._tPos,   config.gridAnimationSpeed);
      o.hBottom.scale.lerp(   o.hBottom._tScale, config.gridAnimationSpeed);
    }
  }

  // rendu
  renderer.render(scene, camera);

  // fade-in du canvas une fois prêt
  const canvas = document.getElementById('webgl-canvas');
  if (canvas && canvas.style.opacity !== '1') canvas.style.opacity = '1';
}

function isMobileBucket(){ return currentBucket==='mobile-h' || currentBucket==='mobile-v'; }

function findLeafAt(worldPos, stateMap){
  let best=null, smallest=Infinity;
  for (const sq of stateMap.values()){
    const half = sq.originalSize/2;
    const inside = worldPos.x>=sq.x-half && worldPos.x<=sq.x+half && worldPos.y>=sq.y-half && worldPos.y<=sq.y+half;
    if (inside && sq.originalSize<smallest){ best=sq; smallest=sq.originalSize; }
  }
  return best;
}
function refineTargetStateAt(worldPos){
  let refined=false, it=0;
  while (it<64){
    it++;
    const leaf = findLeafAt(worldPos, targetState); if (!leaf) break;
    if (imageCells.has(leaf.path) || buttonCells.has(leaf.path)) break;
    if (leaf.depth < TARGET_DEPTH){
      refined=true; targetState.delete(leaf.path);
      const {x,y, originalSize:os, depth:d, path:p} = leaf; const ns=os/2, nd=d+1, o=os/4;
      createQuadTree(x-o, y+o, ns, nd, p+'/0', -1);
      createQuadTree(x+o, y+o, ns, nd, p+'/1', -1);
      createQuadTree(x-o, y-o, ns, nd, p+'/2', -1);
      createQuadTree(x+o, y-o, ns, nd, p+'/3', -1);
    } else break;
  }
  return refined;
}
function updateMouseSquareTarget(worldPos){
  const { w, contentTop, menuHeight } = getLayoutMetrics();

  // --- Dans le header : on réutilise la dernière taille "grille" ---
  if (worldPos.y >= contentTop) {
    // si on n'a pas encore d'historique (ex: souris spawn dans le header),
    // on prend une valeur raisonnable: demi-case D1
    const baseFs = lastGridCursorSizeWorld || Math.max(0, (w/2) - config.borderWidth);
    const fs = Math.max(0, baseFs);
    const half = fs / 2;
    updateDomCursorOverlay(fs, true);

    // Centre = souris, clampé pour rester visible
    let nx = worldPos.x;
    let ny = worldPos.y;
    nx = Math.max(camera.left + half,  Math.min(camera.right - half, nx));
    ny = Math.max(contentTop + half,   Math.min(camera.top   - half, ny));

    mouseSquare.userData.targetPosition.set(nx, ny, 4);
    mouseSquare.userData.targetScale.set(fs, fs, 1);
    cursorBorder.userData.targetPosition.set(nx, ny, 3);
    cursorBorder.userData.targetScale.set(fs + config.borderWidth, fs + config.borderWidth, 1);

    cursorInHeader = true;
    return;
  }

  // --- Dans le contenu : comportement normal (snap grille) ---
  cursorInHeader = false;

  const leaf = findLeafAt(worldPos, targetState); if (!leaf) return;
  const dd = Math.max(0, TARGET_DEPTH - leaf.depth);
  const cell = leaf.originalSize / Math.pow(2, dd);
  const lx = worldPos.x - (leaf.x - leaf.originalSize/2);
  const ly = worldPos.y - (leaf.y - leaf.originalSize/2);
  const ix = Math.max(0, Math.min(Math.floor(lx / cell), Math.pow(2, dd)-1));
  const iy = Math.max(0, Math.min(Math.floor(ly / cell), Math.pow(2, dd)-1));
  const nx = (leaf.x - leaf.originalSize/2) + ix*cell + cell/2;
  const ny = (leaf.y - leaf.originalSize/2) + iy*cell + cell/2;
  const fs = Math.max(0, cell - config.borderWidth);

  // >>> ICI la ligne qu'il te manquait <<<
  updateDomCursorOverlay(fs, false);

  mouseSquare.userData.targetPosition.set(nx, ny, 4);
  mouseSquare.userData.targetScale.set(fs, fs, 1);
  cursorBorder.userData.targetPosition.set(nx, ny, 3);
  cursorBorder.userData.targetScale.set(fs + config.borderWidth, fs + config.borderWidth, 1);

  // ⬅️ on mémorise la taille "grille" pour s'en servir dans le header
  lastGridCursorSizeWorld = fs;
}


function updateDomCursorOverlay(fsWorld, inHeader){
  if (!domCursorEl) return;
  const { viewHeight } = getLayoutMetrics();

  // world -> pixels
  const pxPerWorldY = window.innerHeight / viewHeight;
  const sidePx = Math.max(0, Math.round(fsWorld * pxPerWorldY));

  // récupère la position souris en pixels depuis lastMouseScreenPos
  const cx = (lastMouseScreenPos.x * 0.5 + 0.5) * window.innerWidth;
  const cy = (-lastMouseScreenPos.y * 0.5 + 0.5) * window.innerHeight;

  domCursorEl.style.left = cx + 'px';
  domCursorEl.style.top  = cy + 'px';
  domCursorEl.style.width  = sidePx + 'px';
  domCursorEl.style.height = sidePx + 'px';
  domCursorEl.style.opacity = inHeader ? '1' : '0';
}
  
// Mouse & Click
function onMouseMove(e){
  lastMouseScreenPos.set((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
  needsRefineCheck = true;
}
function onClick(e){
  if (e.altKey){
    const wp = new THREE.Vector3(lastMouseScreenPos.x,lastMouseScreenPos.y,0).unproject(camera);
    logD2At(wp);
    return;
  }

  const wp = new THREE.Vector3(lastMouseScreenPos.x,lastMouseScreenPos.y,0).unproject(camera);
  const { contentTop } = getLayoutMetrics();

  // ignore les clics dans le header
  if (wp.y >= contentTop) return;

  for (const [key, st] of fractalState.entries()){
    if (!st.isButton) continue;
    const half = st.mesh.scale.x/2;
    const inside =
      (wp.x >= st.mesh.position.x - half && wp.x <= st.mesh.position.x + half &&
       wp.y >= st.mesh.position.y - half && wp.y <= st.mesh.position.y + half);
    if (inside && buttonCells.has(key)){
      const { url } = buttonCells.get(key);
      window.location.href = url;
      return;
    }
  }

  reformGridKeepImages();
}

// Outil de repérage
function logD2At(wp){
  const { w, contentTop } = getLayoutMetrics();
  const col = Math.floor((wp.x - camera.left) / w);
  const row = Math.floor((contentTop - wp.y) / w);
  const cx = camera.left + col*w + w/2;
  const cy = contentTop - row*w - w/2;
  const quad = (wp.y > cy ? (wp.x < cx ? 2 : 3) : (wp.x < cx ? 0 : 1));
  console.log(`{ size:'D2', row:${row}, col:${col}, quad:${quad} }`);
}
</script>
</body>
</html>
