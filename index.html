<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fractale — buckets + 3 catégories uniques</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<link rel="preconnect" href="https://cdn.skypack.dev" crossorigin>
<link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js">
<style>
  :root {
    color-scheme: dark;
    /* Hauteur de header par défaut (corrigée au 1er frame) + écart unifié */
    --menu-h: 48px;
    --menu-gap: 16px;
  }
  html, body { height: 100%; }
  body {
    margin: 0; overflow: hidden;
    background-color: #0055ff;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  }

  /* Canvas */
  #webgl-canvas {
    position: fixed; inset: 0; display: block; z-index: 1;
    opacity: 0; transition: opacity .25s ease;
  }

  /* Header */
  #ui-header {
    position: fixed; top: 0; left: 0; right: 0; height: var(--menu-h);
    z-index: 4; pointer-events: none;
  }
  #header-inner {
    height: 100%; display: flex; align-items: center; justify-content: flex-end;
    padding: 0 var(--menu-gap); /* base */
    padding-right: calc(var(--menu-gap) * 2); /* marge verte x2 */
    box-sizing: border-box; pointer-events: none; position: relative;
  }
  #nav-links { display: flex; gap: calc(var(--menu-gap) * 2); align-items: center; white-space: nowrap; pointer-events: auto; } /* espace ABOUT-CONTACT x2 */
  .nav-btn {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
    font-size: 14px; color: #e5e5e5; letter-spacing: .02em; text-decoration: none;
  }
  .nav-btn:hover, .nav-btn:focus { outline: none; color: #f7ff58; }

  #logo-link { pointer-events: auto; display: inline-flex; align-items: center; justify-content: center;
    margin-left: calc(var(--menu-gap) * 2); /* marge orange = verte */
  }
  #logo-overlay {
    height: calc(var(--menu-h) * 0.5);
    max-height: 44px; /* évite le logo trop gros au chargement */
    aspect-ratio: auto; display: block; user-select: none;
  }

  /* Mobile header */
  #mobile-left, #mobile-right {
    display: none; pointer-events: auto; color: #e5e5e5;
    position: absolute; top: 50%; transform: translateY(-50%);
  }
  #mobile-left  { left: var(--menu-gap); }
  #mobile-right { right: var(--menu-gap); }
  .mobile-icon { display: block; width: 22px; height: 22px; }

  @media (max-width: 640px) {
    #header-inner { justify-content: center; }
    #nav-links { display: none; }
    #logo-link { margin-left: 0; } /* mobile: on annule le décalage */
    #mobile-left, #mobile-right { display: inline-flex; align-items: center; }
  }

  @media (prefers-reduced-motion: reduce) { #webgl-canvas { transition: none; } }
</style>
</head>
<body>

<header id="ui-header" aria-label="Top menu">
  <div id="header-inner">
    <!-- Mobile -->
    <a id="mobile-left" href="#about" aria-label="About / Info">
      <svg class="mobile-icon" viewBox="0 0 15 15" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
        <path d="M7.49991 0.876892C3.84222 0.876892 0.877075 3.84204 0.877075 7.49972C0.877075 11.1574 3.84222 14.1226 7.49991 14.1226C11.1576 14.1226 14.1227 11.1574 14.1227 7.49972C14.1227 3.84204 11.1576 0.876892 7.49991 0.876892ZM1.82707 7.49972C1.82707 4.36671 4.36689 1.82689 7.49991 1.82689C10.6329 1.82689 13.1727 4.36671 13.1727 7.49972C13.1727 10.6327 10.6329 13.1726 7.49991 13.1726C4.36689 13.1726 1.82707 10.6327 1.82707 7.49972ZM8.24992 4.49999C8.24992 4.9142 7.91413 5.24999 7.49992 5.24999C7.08571 5.24999 6.74992 4.9142 6.74992 4.49999C6.74992 4.08577 7.08571 3.74999 7.49992 3.74999C7.91413 3.74999 8.24992 4.08577 8.24992 4.49999ZM6.00003 5.99999H6.50003H7.50003C7.77618 5.99999 8.00003 6.22384 8.00003 6.49999V9.99999H8.50003H9.00003V11H8.50003H7.50003H6.50003H6.00003V9.99999H6.50003H7.00003V6.99999H6.50003H6.00003V5.99999Z" fill-rule="evenodd" clip-rule="evenodd"/>
      </svg>
    </a>

    <!-- Desktop/Tablette -->
    <nav id="nav-links" aria-label="Primary">
      <a class="nav-btn" href="#about">[ ABOUT ]</a>
      <a class="nav-btn" href="#contact">[ CONTACT ]</a>
    </nav>

    <!-- Logo -->
    <a id="logo-link" href="/" aria-label="Home">
      <img id="logo-overlay" src="https://i.postimg.cc/nz6hx67W/logo-sooxy-art.png" alt="Logo Sooxy Art" loading="eager" decoding="async" />
    </a>

    <!-- Mobile -->
    <a id="mobile-right" href="#contact" aria-label="Contact">
      <svg class="mobile-icon" viewBox="0 0 15 15" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
        <path d="M1 2C0.447715 2 0 2.44772 0 3V12C0 12.5523 0.447715 13 1 13H14C14.5523 13 15 12.5523 15 12V3C15 2.44772 14.5523 2 14 2H1ZM1 3L14 3V3.92494C13.9174 3.92486 13.8338 3.94751 13.7589 3.99505L7.5 7.96703L1.24112 3.99505C1.16621 3.94751 1.0826 3.92486 1 3.92494V3ZM1 4.90797V12H14V4.90797L7.74112 8.87995C7.59394 8.97335 7.40606 8.97335 7.25888 8.87995L1 4.90797Z" fill-rule="evenodd" clip-rule="evenodd"/>
      </svg>
    </a>
  </div>
</header>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
    "simplex-noise": "https://cdn.skypack.dev/simplex-noise@4.0.1"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { createNoise2D } from 'simplex-noise';

/* ——— Buckets (avec hystérésis) ——— */
const BUCKETS = [
  { id:'desktop-32:9', match:(w,h)=> w>=1025 && (w/h)>=3.1,                  grid:{cols:6, rows:2} },
  { id:'desktop-21:9', match:(w,h)=> w>=1025 && (w/h)>=2.0 && (w/h)<3.1,     grid:{cols:5, rows:2} },
  { id:'desktop-16:9', match:(w,h)=> (w/h)>=1.6 && (w/h)<2.0 && w>=768,      grid:{cols:4, rows:2} },

  { id:'tablet-4:3',   match:(w,h)=> (w/h)>=1.28 && (w/h)<1.6 && w>=641 && w<1025, grid:{cols:3, rows:2} },
  { id:'tablet-3:4',   match:(w,h)=> (h/w)>=1.2  && (h/w)<1.5 && w>=641 && w<1025, grid:{cols:2, rows:3} },
  { id:'tablet-9:16',  match:(w,h)=> (h/w)>=1.5  && w>=641 && w<1025,              grid:{cols:2, rows:4} },

  { id:'mobile-h',     match:(w,h)=> w<=640 && w>h, grid:{cols:3, rows:2} },
  { id:'mobile-v',     match:(w,h)=> w<=640 && h>=w, grid:{cols:2, rows:4} },
];
const HYST = 0.03;
let currentBucket = null;
let lastAspect = null;
function pickBucket(w, h){
  const a = w/h;
  if (currentBucket && lastAspect && Math.abs(a - lastAspect) < HYST) return currentBucket;
  for (const b of BUCKETS) { if (b.match(w, h)) { lastAspect = a; return b.id; } }
  lastAspect = a;
  return 'desktop-16:9';
}

/* ——— Couleurs & config ——— */
const prefersReducedMotion = matchMedia('(prefers-reduced-motion: reduce)').matches;
const COLORS = {
  background: 0x0055ff,
  square:     0x08090a,
  accent:     0xf7ff58,
  textCSS:    '#e5e5e5'
};
const config = {
  borderWidth: 0.005,
  backgroundColor: COLORS.background,
  darkColor: COLORS.square,
  cursorColor: COLORS.accent,
  initialProbabilityToSubdivide: 0.99,
  depthDecayFactor: 0.04,
  noiseScale: 1,
  minDepth: 1,
  maxDepthVariation: 7,
  mouseSquareAnimationSpeed: prefersReducedMotion ? 0.15 : 0.4,
  gridAnimationSpeed: prefersReducedMotion ? 0.05 : 0.08,
  grainOpacity: prefersReducedMotion ? 0.0 : 0.08,
  showDots: true,
  dotSize: 0.12,
  dotColor: COLORS.accent,
  dotSizeIsRelative: false,
  baseColsOverride: null,
};

/* ——— Vœux d’images par bucket ——— */
const LAYOUT_WISH = {
  'desktop-32:9': { wantD1:1, wantD2:6, buttonsOnD2:true  },
  'desktop-21:9': { wantD1:1, wantD2:5, buttonsOnD2:true  },
  'desktop-16:9': { wantD1:1, wantD2:4, buttonsOnD2:true  },

  'tablet-4:3'  : { wantD1:1, wantD2:4, buttonsOnD2:true  },
  'tablet-3:4'  : { wantD1:1, wantD2:4, buttonsOnD2:false }, /* portrait : tolère D1 */
  'tablet-9:16' : { wantD1:1, wantD2:4, buttonsOnD2:false },

  'mobile-h'    : { wantD1:0, wantD2:4, buttonsOnD2:false },
  'mobile-v'    : { wantD1:0, wantD2:4, buttonsOnD2:false },

};

/* ——— Catégories (3 uniques) ——— */
const CATEGORIES = [
  { key:'motion',  label:'Motion\\nDesign',   url:'/motion-design' },
  { key:'fractal', label:'Fractal\\nArt',     url:'/fractal-art'   },
  { key:'code',    label:'Creative\\nCoding', url:'/creative-coding' }
];
const REQUIRED_BUTTONS = 3;

/* ——— Runtime state ——— */
let scene, camera, renderer, noise2D, rngFn, mouseSquare, cursorBorder, grainPlane, menuPlane, menuBorderBottom;
let lastMouseScreenPos = new THREE.Vector2(0, 0);
const fractalState = new Map(); const meshPool = []; const dotMeshPool = [];
let targetState = new Map();
let darkMaterial, cursorMaterial, geometry, dotMaterial, menuBorderMaterial;
let needsBaseUpdate = true; let needsRefineCheck = false; let refineBudgetPerFrame = 64;

const imageCells = new Set(); const buttonCells = new Map(); let persistentButtonPaths = [];
const imageAssignment = new Map(); const imageSlots = new Set(); const buttonSlots = new Set();
const materialCache = new Map(); const textureLoader = new THREE.TextureLoader();

let baseCols = 4, baseRowsPrimary = 2, WANT_D1 = 1, WANT_D2 = 4, BUTTONS_ON_D2 = true;
let TARGET_DEPTH = prefersReducedMotion ? 5 : 7;

/* ——— Images locales (img/BY-pics/01.png, 02.png, 03.png, …) ——— */
let imageTextures = [];
const LOCAL_IMG_DIR = 'img/BY-pics/'; // le dossier "img" est à côté de index.html
const IMG_EXT = '.png';
const IMG_PAD = 2;          // "01", "02", …
const MAX_INDEX = 200;      // on teste 01 → 200
const STOP_AFTER_MISSES = 10; // on s'arrête après 10 manquants d'affilée si on en a déjà trouvé

async function scanLocalImages() {
  imageTextures = [];
  let misses = 0;
  for (let i = 1; i <= MAX_INDEX; i++) {
    const num = String(i).padStart(IMG_PAD, '0');
    const url = `${LOCAL_IMG_DIR}${num}${IMG_EXT}`;
    const ok = await imageExists(url);
    if (ok) { imageTextures.push(url); misses = 0; }
    else { misses++; if (misses >= STOP_AFTER_MISSES && imageTextures.length > 0) break; }
  }
  // Sécurité : duplique la liste pour éviter d'en manquer si la grille veut plus d'images
  if (imageTextures.length > 0 && imageTextures.length < 12) {
    const base = imageTextures.slice();
    while (imageTextures.length < 12) {
      imageTextures.push(base[imageTextures.length % base.length]);
    }
  }
}

function imageExists(url) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
    // petit cache-buster pour être sûr
    img.src = url + '?v=' + Math.random();
  });
}


/* ——— Utils ——— */
function hashCode(str){ let h=0; for(let i=0;i<str.length;i++) h=((h<<5)-h+str.charCodeAt(i))|0; return h; }
function saltedKey(path, salt){ return (hashCode(path) ^ salt) | 0; }
const sessionSalt = (Math.random()*0x7fffffff) | 0; // sel aléatoire par session

function reseed(){
  rngFn = Math.random;
  noise2D = createNoise2D(Math.random); // nouvelle permutation aléatoire
}

/* Layout helpers */
function getLayoutMetrics(){
  const viewHeight = camera.top - camera.bottom;
  const viewWidth  = camera.right - camera.left;
  const w = viewWidth / baseCols;
  const menuHeight = Math.max(w / 8, 0.5);
  const contentTop = camera.top - menuHeight;

  // Synchronise la hauteur du header CSS au tout premier frame
  const pxMenu = (menuHeight / viewHeight) * window.innerHeight;
  document.documentElement.style.setProperty('--menu-h', `${pxMenu}px`);

  return { viewHeight, viewWidth, w, menuHeight, contentTop };
}
function isFullyVisible(x, y, size, contentTop){
  const eps = config.borderWidth * 2;
  const half = size / 2;
  return (
    x - half >= camera.left + eps &&
    x + half <= camera.right - eps &&
    y - half >= camera.bottom + eps &&
    y + half <= contentTop - eps
  );
}

function isVisibleEnough(x, y, size, contentTop, minRatio = 0.5){
  const half = size / 2;
  const left   = Math.max(camera.left,   x - half);
  const right  = Math.min(camera.right,  x + half);
  const bottom = Math.max(camera.bottom, y - half);
  const top    = Math.min(contentTop,    y + half);
  const w = Math.max(0, right - left);
  const h = Math.max(0, top - bottom);
  const overlap = w * h;
  const full = size * size;
  return (overlap / full) >= minRatio;
}

function depth2SlotKey(x, y, w, contentTop){
  const cell = w/2;
  const col = Math.floor((x - camera.left) / cell);
  const row = Math.floor((contentTop - y) / cell);
  return `${col},${row}`;
}
function depth1SlotKey(x, y, w, contentTop){
  const cell = w;
  const col = Math.floor((x - camera.left) / cell);
  const row = Math.floor((contentTop - y) / cell);
  return `D1:${col},${row}`;
}
function key2col(key){
  const k = key.startsWith('D1:') ? key.slice(3) : key;
  return parseInt(k.split(',')[0],10);
}
function isAdjacentIn(set, key){
  const m = key.startsWith('D1:') ? key.slice(3) : key;
  const [c,r]=m.split(',').map(Number);
  const neigh = [[c-1,r],[c+1,r],[c,r-1],[c,r+1]];
  if (set.has(key)) return true;
  for (const [cc,rr] of neigh){
    const k2 = key.startsWith('D1:') ? `D1:${cc},${rr}` : `${cc},${rr}`;
    if (set.has(k2)) return true;
  }
  return false;
}
const isLandscape = ()=> window.innerWidth >= window.innerHeight;
const isMobileBucket = ()=> currentBucket==='mobile-h' || currentBucket==='mobile-v';

/* THREE init */
const canvas = document.createElement('canvas'); canvas.id = 'webgl-canvas'; document.body.appendChild(canvas);

// Démarre l'animation seulement quand bootstrap a fini
(async () => {
  init();
  await bootstrap();
  animate();
})();

function init(){
  scene = new THREE.Scene(); scene.background = new THREE.Color(config.backgroundColor);

  const aspect = window.innerWidth / window.innerHeight; const height = 10; const width = height * aspect;
  camera = new THREE.OrthographicCamera(-width/2, width/2, height/2, -height/2, 1, 1000); camera.position.z = 10;

  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, canvas, powerPreference:'high-performance' });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));
  renderer.setSize(window.innerWidth, window.innerHeight);

  geometry = new THREE.PlaneGeometry(1,1);
  cursorMaterial = new THREE.MeshBasicMaterial({ color: config.cursorColor, transparent:true, opacity:0.85 });
  darkMaterial   = new THREE.MeshBasicMaterial({ color: config.darkColor });
  dotMaterial    = new THREE.MeshBasicMaterial({ color: config.dotColor });
  menuBorderMaterial = new THREE.MeshBasicMaterial({ color: config.backgroundColor });

  mouseSquare = new THREE.Mesh(geometry, cursorMaterial); mouseSquare.userData.targetPosition = new THREE.Vector3(); mouseSquare.userData.targetScale = new THREE.Vector3(); mouseSquare.renderOrder = 4; scene.add(mouseSquare);
  cursorBorder = new THREE.Mesh(geometry, darkMaterial); cursorBorder.userData.targetPosition = new THREE.Vector3(); cursorBorder.userData.targetScale = new THREE.Vector3(); cursorBorder.renderOrder = 3; scene.add(cursorBorder);

  createGrainPlane(); createMenuPlane();

  // interactions
  window.addEventListener('mousemove', onMouseMove, { passive:true });
  window.addEventListener('click', onClick, { passive:true });

  // hauteur header correcte au 1er frame
  requestAnimationFrame(()=>{ updateMenuGeometry(); });
}

async function bootstrap(){
  // IMPORTANT : charger la liste des images locales d'abord
  await scanLocalImages();   // ← c'est ça qui manquait

  // Ensuite seulement on construit le layout
  const w = window.innerWidth, h = window.innerHeight;
  currentBucket = pickBucket(w, h);
  applyBucket();
  resetFractalRandom();
}


function applyBucket(){
  const b = BUCKETS.find(x=>x.id===currentBucket);

  // Lignes primaires
  baseRowsPrimary = b?.grid.rows || 2;

  // Colonnes de base (UNE SEULE chaîne if/else if/else — pas de doublon après !)
  if (isMobileBucket()) {
    baseCols = 2;                                // un D1 = 50% largeur
    baseRowsPrimary = Math.max(baseRowsPrimary, 3); // 3 lignes "content" en mobile
  } else if (config.baseColsOverride != null) {
    baseCols = Math.max(1, config.baseColsOverride);
  } else if (config.targetCellPx) {
    baseCols = Math.max(1, Math.round(window.innerWidth / config.targetCellPx));
  } else {
    baseCols = b?.grid.cols || 4;
  }

  // Souhaits par bucket
  const wish = LAYOUT_WISH[currentBucket] || { wantD1:1, wantD2:4, buttonsOnD2:true };
  WANT_D1 = wish.wantD1;
  WANT_D2 = wish.wantD2;
  BUTTONS_ON_D2 = wish.buttonsOnD2;

  // (facultatif) log de debug
  // console.log('bucket:', currentBucket, { baseCols, baseRowsPrimary, WANT_D1, WANT_D2, BUTTONS_ON_D2 });
}


/* Grain + Menu */
function createGrainPlane(){
  const mat = new THREE.ShaderMaterial({
    transparent: true,
    uniforms: { uOpacity: { value: config.grainOpacity } },
    vertexShader: 'varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }',
    fragmentShader:'uniform float uOpacity; varying vec2 vUv; float r(vec2 st){ return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);} void main(){ vec2 uv=gl_FragCoord.xy/512.0; float g=r(uv); gl_FragColor=vec4(1.0,1.0,1.0,g*uOpacity); }'
  });
  grainPlane = new THREE.Mesh(new THREE.PlaneGeometry(1,1), mat);
  grainPlane.position.z = 1; grainPlane.renderOrder = 2; scene.add(grainPlane);
  updateGrainPlaneSize();
}
function createMenuPlane(){
  menuPlane = new THREE.Mesh(new THREE.PlaneGeometry(1,1), darkMaterial); menuPlane.position.z = 0.1; menuPlane.renderOrder = 0; scene.add(menuPlane);
  menuBorderBottom = new THREE.Mesh(new THREE.PlaneGeometry(1,1), menuBorderMaterial); menuBorderBottom.position.z = 0.11; menuBorderBottom.renderOrder = 1; scene.add(menuBorderBottom);
  updateMenuGeometry();
}
function updateMenuGeometry(){
  const { viewHeight, viewWidth, w } = getLayoutMetrics();
  const menuHeight = Math.max(w/8, 0.5);
  const contentTop = camera.top - menuHeight;
  menuPlane.scale.set(viewWidth, menuHeight, 1);
  menuPlane.position.set((camera.left+camera.right)/2, camera.top - menuHeight/2, 0.1);
  menuBorderBottom.scale.set(viewWidth, config.borderWidth, 1);
  menuBorderBottom.position.set((camera.left+camera.right)/2, contentTop, 0.11);
}
function updateGrainPlaneSize(){ if(!grainPlane) return; const h=camera.top - camera.bottom; const w=camera.right - camera.left; grainPlane.scale.set(w, h, 1); }

/* Resize (debounced reload at resize end) */
let resizeTimer=null;
window.addEventListener('resize', ()=>{
  const aspect = window.innerWidth / window.innerHeight; const height = 10; const width = height * aspect;
  camera.left=-width/2; camera.right=width/2; camera.top=height/2; camera.bottom=-height/2; camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  updateGrainPlaneSize(); updateMenuGeometry();

  if (resizeTimer) clearTimeout(resizeTimer);
  resizeTimer = setTimeout(()=>{
    window.location.reload(); // recharge après la fin du redimensionnement
  }, 250);
}, { passive:true });

/* QuadTree / Build */
function resetFractalRandom(){
  // tente plusieurs fois de suite de construire une grille valide (3 boutons uniques)
  for (let tries=0; tries<50; tries++){
    reseed(); // RNG + noise aléatoires
    targetState.clear(); imageCells.clear(); buttonCells.clear();
    imageAssignment.clear(); imageSlots.clear(); buttonSlots.clear();
    const ok = updateFractalBase(true); // true si 3 boutons bien placés ET uniques
    if (ok){
      syncStateToMeshes();
      needsBaseUpdate = false;
      return;
    }
  }
  // en dernier recours, on force quand même un affichage : on place les 3 catégories
  // sur les 3 premières cases content visibles, puis on synchronise.
  ensureFallbackButtons();
  syncStateToMeshes();
  needsBaseUpdate = false;
}
function createQuadTree(x, y, size, depth, path, maxDepthOverride=-1){
  const noiseVal = (noise2D(x*config.noiseScale, y*config.noiseScale)+1)/2;
  const regionalMaxDepth = maxDepthOverride !== -1 ? maxDepthOverride : config.minDepth + Math.floor(noiseVal * config.maxDepthVariation);
  const currentProbability = config.initialProbabilityToSubdivide - depth * config.depthDecayFactor;
  const stop = depth >= regionalMaxDepth || (depth>0 && rngFn()>currentProbability) || size/2 <= config.borderWidth;
  if (stop){
    const scale = size - config.borderWidth;
    if (scale > 0) targetState.set(path, { x, y, size:scale, depth, path, originalSize:size });
    return;
  }
  const ns = size/2, o = size/4, d = depth+1;
  createQuadTree(x-o, y+o, ns, d, path+'/0', maxDepthOverride);
  createQuadTree(x+o, y+o, ns, d, path+'/1', maxDepthOverride);
  createQuadTree(x-o, y-o, ns, d, path+'/2', maxDepthOverride);
  createQuadTree(x+o, y-o, ns, d, path+'/3', maxDepthOverride);
}

function updateFractalBase(forceFull=false){
  targetState.clear();
  const { w, contentTop } = getLayoutMetrics();

  // 1) D1 de base (puisqu'on passe maxDepthOverride=1 sur mobile)
  const visibleRows = Math.ceil((contentTop - camera.bottom) / w);
  const totalRows   = Math.max(baseRowsPrimary, visibleRows);

  for (let row=0; row<totalRows; row++){
    const isPrimary = row < baseRowsPrimary;
    for (let col=0; col<baseCols; col++){
      const pref = isPrimary ? 'content' : 'filler';
      const path = `${pref}/${row}/${col}`;
      const x = camera.left + col*w + w/2;
      const y = contentTop - row*w - w/2;
      createQuadTree(x, y, w, 1, path, isMobileBucket() ? 1 : -1);
    }
  }

  // 2) Mobile : motif déterministe — Desktop/Tablet : logique standard
  if (isMobileBucket()){
    forceMobilePattern(); // -> 3 D1 fixes + D2 ailleurs
  } else {
    const requiredD2 = (BUTTONS_ON_D2 ? REQUIRED_BUTTONS : 0) + WANT_D2;
    ensureMinDepth2Cells(requiredD2, WANT_D1);
  }

  // 3) Boutons puis images
  const okButtons = chooseButtonsThenImages(forceFull);

  // 4) Raffinement "ambiance"
  if (okButtons) sprinkleRefinements(isMobileBucket() ? 128 : 24);

  return okButtons;
}


// Force un motif mobile : garde 3 D1 fixes et subdivise le reste en D2
function forceMobilePattern(){
  if (!isMobileBucket()) return;

  const { w, contentTop } = getLayoutMetrics();
  const fixed = new Set(['content/0/1','content/1/0','content/2/1']); // (row,col)

  for (const [path, s] of Array.from(targetState.entries())){
    if (!path.startsWith('content/')) continue;
    if (!isVisibleEnough(s.x, s.y, s.originalSize, contentTop, 0.05)) continue;

    // On ne touche qu'aux D1
    const isD1 = Math.abs(s.originalSize - w) < 1e-6;
    if (!isD1) continue;

    // Ces 3 restent gros, tout le reste est subdivisé en D2
    if (fixed.has(path)) continue;

    // Remplace ce D1 par ses 4 D2
    targetState.delete(path);
    const size = s.originalSize, ns = size/2, d = 2, o = size/4;
    const quads = [
      {x:s.x-o, y:s.y+o, suffix:'/0'},
      {x:s.x+o, y:s.y+o, suffix:'/1'},
      {x:s.x-o, y:s.y-o, suffix:'/2'},
      {x:s.x+o, y:s.y-o, suffix:'/3'},
    ];
    for (const q of quads){
      // Partiellement visible ? ok (évite les trous collés aux bords)
      if (!isVisibleEnough(q.x, q.y, ns, contentTop, 0.05)) continue;

      const p = path + q.suffix;
      targetState.set(p, { x:q.x, y:q.y, size:ns - config.borderWidth, depth:d, path:p, originalSize:ns });
    }
  }
}



function isForbiddenD2Edge(key2){
  // Desktop/Tablet en paysage : interdire les colonnes w/2 extrêmes pour les boutons
  const id = currentBucket;
  const desktopOrTab = id.startsWith('desktop') || id.startsWith('tablet');
  if (!desktopOrTab) return false;
  if (!isLandscape()) return false;
  const c = key2col(key2);
  const nColsD2 = baseCols * 2;
  return (c===0) || (c===nColsD2-1);
}

function chooseButtonsThenImages(forceFull){
  imageCells.clear(); buttonCells.clear(); imageSlots.clear(); buttonSlots.clear();
  const { w, contentTop } = getLayoutMetrics();

  // 1) Récupère toutes les cases D1 et D2 visibles
  const d1=[], d2=[];
  for (const [path,s] of targetState.entries()){
    if (!path.startsWith('content/')) continue;
    if (!isFullyVisible(s.x, s.y, s.originalSize, contentTop)) continue;
    if (Math.abs(s.originalSize - w)   < 1e-6) d1.push({ path, s, key1: depth1SlotKey(s.x,s.y,w,contentTop) });
    if (Math.abs(s.originalSize - w/2) < 1e-6) d2.push({ path, s, key2: depth2SlotKey(s.x,s.y,w,contentTop) });
  }
  const salt = sessionSalt ^ 0x9E3779B9;
  d1.sort((a,b)=> saltedKey(a.path, salt)      - saltedKey(b.path, salt));
  d2.sort((a,b)=> saltedKey(a.path, salt+777 ) - saltedKey(b.path, salt+777));

  // ← UNE SEULE déclaration, ici
  const HAS_IMAGES = imageTextures && imageTextures.length > 0;

  /* ==================== MOBILE : 3 positions figées ==================== */
  if (isMobileBucket()){
    const fixedPathsAll = ['content/0/1','content/1/0','content/2/1'];
    const fixedPaths = fixedPathsAll.filter(p => {
      const s = targetState.get(p);
      return s && isVisibleEnough(s.x, s.y, s.originalSize, contentTop, 0.4);
    });

    // si une case manque (écran trop court), on complète avec d’autres D1 visibles (content OU filler)
    const d1All = [];
    for (const [path,s] of targetState.entries()){
      if (!/^(content|filler)\//.test(path)) continue;
      if (!isVisibleEnough(s.x, s.y, s.originalSize, contentTop, 0.4)) continue;
      if (Math.abs(s.originalSize - w) < 1e-6) d1All.push(path);
    }

    const picked = [...fixedPaths];
    for (const p of d1All){
      if (picked.length >= REQUIRED_BUTTONS) break;
      if (!picked.includes(p)) picked.push(p);
    }

    persistentButtonPaths = picked.slice(0, REQUIRED_BUTTONS);
    if (persistentButtonPaths.length < REQUIRED_BUTTONS) return false;

    const fixedOrder = ['motion','fractal','code'];
    for (let i=0; i<REQUIRED_BUTTONS; i++){
      const spec = CATEGORIES.find(c=>c.key===fixedOrder[i]);
      const path = persistentButtonPaths[i];
      buttonCells.set(path, { label: spec.label, url: spec.url, key: spec.key });
    }

  } else {
    /* ==================== DESKTOP/TABLET : logique existante ==================== */
    const pickedBtn = [];
    if (BUTTONS_ON_D2) {
      for (const it of d2) {
        if (pickedBtn.length>=REQUIRED_BUTTONS) break;
        if (isForbiddenD2Edge(it.key2)) continue;
        if (isAdjacentIn(buttonSlots, it.key2)) continue;
        pickedBtn.push(it.path); buttonSlots.add(it.key2);
      }
      for (const it of d2) {
        if (pickedBtn.length>=REQUIRED_BUTTONS) break;
        if (isForbiddenD2Edge(it.key2)) continue;
        if (!pickedBtn.includes(it.path)) { pickedBtn.push(it.path); buttonSlots.add(it.key2); }
      }
      for (const it of d1) {
        if (pickedBtn.length>=REQUIRED_BUTTONS) break;
        if (isAdjacentIn(buttonSlots, it.key1)) continue;
        pickedBtn.push(it.path); buttonSlots.add(it.key1);
      }
      for (const it of d1) {
        if (pickedBtn.length>=REQUIRED_BUTTONS) break;
        if (!pickedBtn.includes(it.path)) { pickedBtn.push(it.path); buttonSlots.add(it.key1); }
      }
    } else {
      for (const it of d1) {
        if (pickedBtn.length>=REQUIRED_BUTTONS) break;
        if (isAdjacentIn(buttonSlots, it.key1)) continue;
        pickedBtn.push(it.path); buttonSlots.add(it.key1);
      }
      for (const it of d1) {
        if (pickedBtn.length>=REQUIRED_BUTTONS) break;
        if (!pickedBtn.includes(it.path)) { pickedBtn.push(it.path); buttonSlots.add(it.key1); }
      }
      for (const it of d2) {
        if (pickedBtn.length>=REQUIRED_BUTTONS) break;
        if (isForbiddenD2Edge(it.key2)) continue;
        if (isAdjacentIn(buttonSlots, it.key2)) continue;
        pickedBtn.push(it.path); buttonSlots.add(it.key2);
      }
      for (const it of d2) {
        if (pickedBtn.length>=REQUIRED_BUTTONS) break;
        if (!pickedBtn.includes(it.path)) { pickedBtn.push(it.path); buttonSlots.add(it.key2); }
      }
    }
    persistentButtonPaths = pickedBtn.slice(0, REQUIRED_BUTTONS);
    if (persistentButtonPaths.length < REQUIRED_BUTTONS) return false;

    // attribution aléatoire des 3 catégories uniques (desktop/tablette)
    const order = [0,1,2];
    for (let i=order.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [order[i],order[j]]=[order[j],order[i]]; }
    for (let i=0; i<REQUIRED_BUTTONS; i++){
      const path = persistentButtonPaths[i];
      if (path && targetState.has(path)) {
        const spec = CATEGORIES[order[i]];
        buttonCells.set(path, { label: spec.label, url: spec.url, key: spec.key });
      }
    }
    // anti-doublon
    const seen = new Map();
    const missing = new Set(CATEGORIES.map(c=>c.key));
    for (const p of persistentButtonPaths){
      const k = buttonCells.get(p)?.key;
      if (k){ missing.delete(k); seen.set(k, (seen.get(k)||0)+1); }
    }
    if (missing.size>0){
      const missingKeys = Array.from(missing);
      for (const [k,count] of seen.entries()){
        if (count>1 && missingKeys.length>0){
          let replaced = false;
          for (const p of persistentButtonPaths){
            const info = buttonCells.get(p);
            if (info?.key===k && replaced){
              const mKey = missingKeys.shift();
              const spec = CATEGORIES.find(c=>c.key===mKey);
              if (spec){ buttonCells.set(p, { label: spec.label, url: spec.url, key: spec.key }); }
              break;
            }
            if (info?.key===k && !replaced){ replaced = true; }
          }
        }
      }
    }
  }

  /* 2) Images — D1 = 0 sur mobile, donc seulement des D2 autour */
  const chosen = new Set();
  const buttonSet = new Set(persistentButtonPaths);
  const localImgSlots = new Set();

  // D1 image (seulement s’il y a des images)
  if (HAS_IMAGES && WANT_D1 > 0) {
    for (const c of d1) {
      if (buttonSet.has(c.path)) continue;
      chosen.add(c.path);
      const half = w/2;
      const quads = [
        depth2SlotKey(c.s.x - half/2, c.s.y + half/2, w, contentTop),
        depth2SlotKey(c.s.x + half/2, c.s.y + half/2, w, contentTop),
        depth2SlotKey(c.s.x - half/2, c.s.y - half/2, w, contentTop),
        depth2SlotKey(c.s.x + half/2, c.s.y - half/2, w, contentTop),
      ];
      for (const k of quads){ localImgSlots.add(k); imageSlots.add(k); }
      break;
    }
  }

  // D2 images (seulement s’il y a des images)
  let pickedD2 = 0;
  if (HAS_IMAGES) {
    for (const c of d2) {
      if (pickedD2 >= WANT_D2) break;
      if (buttonSet.has(c.path)) continue;
      if (isAdjacentIn(localImgSlots, c.key2)) continue;
      chosen.add(c.path); localImgSlots.add(c.key2); imageSlots.add(c.key2); pickedD2++;
    }
    for (const c of d2) {
      if (pickedD2 >= WANT_D2) break;
      if (buttonSet.has(c.path)) continue;
      if (chosen.has(c.path)) continue;
      chosen.add(c.path); imageSlots.add(c.key2); pickedD2++;
    }
  }

  // Applique la sélection d’images (si aucune image dispo, chosen reste vide → tout noir)
  for (const p of chosen) imageCells.add(p);

  // Textures sans doublon
  const used = new Set();
  for (const p of imageCells) if (imageAssignment.has(p)) used.add(imageAssignment.get(p));
  for (const p of imageCells) {
    if (!imageAssignment.has(p)) {
      let idx=0; while (used.has(idx) && idx<imageTextures.length) idx++;
      imageAssignment.set(p, idx); used.add(idx);
    }
  }
  for (const k of Array.from(imageAssignment.keys())) if (!imageCells.has(k)) imageAssignment.delete(k);

  return true;
}



/* Fallback ultime si jamais 3 boutons ne sont pas trouvés après 50 essais */
function ensureFallbackButtons(){
  const { w, contentTop } = getLayoutMetrics();
  const candidates = [];
  for (const [path,s] of targetState.entries()){
    if (!path.startsWith('content/')) continue;
    if (!isFullyVisible(s.x, s.y, s.originalSize, contentTop)) continue;
    candidates.push({ path, s });
  }
  candidates.sort((a,b)=> a.s.y===b.s.y ? a.s.x - b.s.x : b.s.y - a.s.y); // en haut-gauche -> droite
  const need = Math.min(REQUIRED_BUTTONS, candidates.length);
  const order = [0,1,2];
  for (let i=order.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [order[i],order[j]]=[order[j],order[i]]; }
  for (let i=0;i<need;i++){
    const p = candidates[i].path;
    const spec = CATEGORIES[order[i]];
    buttonCells.set(p, { label: spec.label, url: spec.url, key: spec.key });
    if (!persistentButtonPaths.includes(p)) persistentButtonPaths.push(p);
  }
}

function ensureMinDepth2Cells(required, preserveD1Count){
  const { w, contentTop } = getLayoutMetrics();

  // (utilisée côté desktop/tablette)
  const protectedD1 = new Set(['D1:1,0','D1:0,1','D1:1,2']);

  let d1 = [], d2 = [];
  for (const [path, s] of targetState.entries()){
    if (!path.startsWith('content/')) continue;
    if (!isFullyVisible(s.x, s.y, s.originalSize, contentTop)) continue;

    if (Math.abs(s.originalSize - w) < 1e-6){
      const key1 = depth1SlotKey(s.x, s.y, w, contentTop);
      if (!protectedD1.has(key1)) d1.push({ path, s });
    }
    if (Math.abs(s.originalSize - w/2) < 1e-6){
      d2.push({ path, s });
    }
  }

  if (d2.length >= required) return;

  d1.sort((a,b)=> hashCode(a.path) - hashCode(b.path));
  let remainingD1 = d1.length;

  for (const {path, s} of d1){
    if (d2.length >= required) break;
    if ((remainingD1 - 1) < preserveD1Count) break;

    targetState.delete(path); remainingD1--;
    const size=s.originalSize, ns=size/2, d=2, o=size/4;
    const quads = [
      {x:s.x-o, y:s.y+o, suffix:'/0'},
      {x:s.x+o, y:s.y+o, suffix:'/1'},
      {x:s.x-o, y:s.y-o, suffix:'/2'},
      {x:s.x+o, y:s.y-o, suffix:'/3'},
    ];
    for (const q of quads){
      if (!isVisibleEnough(q.x, q.y, ns, contentTop, 0.05)) continue;
      const p = path + q.suffix;
      targetState.set(p, { x:q.x, y:q.y, size:ns - config.borderWidth, depth:d, path:p, originalSize:ns });
      d2.push({ path:p, s:targetState.get(p) });
      if (d2.length >= required) break;
    }
  }
}


/* Subdivisions d'ambiance non destructives */
function sprinkleRefinements(maxOps=24){
  const candidates = [];
  for (const [path,s] of targetState.entries()){
    // Sur mobile : on inclut aussi les "fillers" pour subdiviser le bas.
    // Sinon (desktop/tablette) on garde le comportement d'origine (content seulement).
    if (!isMobileBucket() && !path.startsWith('content/')) continue;

    if (imageCells.has(path) || buttonCells.has(path)) continue;
    candidates.push({ path, s });
  }
  const salt = sessionSalt ^ 0xABCDEF;
  candidates.sort((a,b)=> saltedKey(a.path, salt) - saltedKey(b.path, salt));
  let ops=0;
  for (const it of candidates){
    if (ops>=maxOps) break;
    if (it.s.depth < TARGET_DEPTH) {
      targetState.delete(it.path);
      const { x,y, originalSize:os, depth:d, path:p } = it.s;
      const ns = os/2, nd = d+1, o = os/4;
      // Ici on enlève la limite (override = -1) pour pouvoir raffiner
      createQuadTree(x-o, y+o, ns, nd, p+'/0', -1);
      createQuadTree(x+o, y+o, ns, nd, p+'/1', -1);
      createQuadTree(x-o, y-o, ns, nd, p+'/2', -1);
      createQuadTree(x+o, y-o, ns, nd, p+'/3', -1);
      ops++;
    }
  }
}


/* Materials */
function getImageMaterial(url){
  if (!url) return darkMaterial;           // ← fallback noir si pas d’URL
  if (materialCache.has(url)) return materialCache.get(url);
  const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, map: null });
  textureLoader.load(url, tex=>{
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
    mat.map = tex; mat.needsUpdate = true;
  }, undefined, ()=>{                       // onError → noir
    mat.map = null; mat.color.set(COLORS.square);
    mat.needsUpdate = true;
  });
  materialCache.set(url, mat);
  return mat;
}

function makeTopRightLabelSprite(text, squareSize){
  const lines = text.split('\\n');
  const cvs = document.createElement('canvas'); const W=1024, H=768;
  cvs.width = W; cvs.height = H;
  const ctx = cvs.getContext('2d');
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = COLORS.textCSS;
  ctx.textBaseline = 'top'; ctx.textAlign = 'right';
  const fontPx = Math.floor(H * 0.11);
  ctx.font = `700 ${fontPx}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace`;
  const margin = Math.floor(H * 0.08); const lineGap = Math.floor(fontPx * 0.12);
  let y = margin; for (const line of lines){ ctx.fillText(line, W - margin, y); y += fontPx + lineGap; }
  const tex = new THREE.CanvasTexture(cvs); tex.colorSpace = THREE.SRGBColorSpace;
  const sprMat = new THREE.SpriteMaterial({ map: tex, depthTest:false, depthWrite:false, transparent:true, color: new THREE.Color(COLORS.textCSS) });
  const spr = new THREE.Sprite(sprMat); const aspect = H/W; spr.scale.set(squareSize, squareSize*aspect, 1); spr.center.set(1,1); spr.renderOrder = 6; return spr;
}

/* Sync meshes */
function syncStateToMeshes(){
  const newKeys = new Set(targetState.keys());
  for (const [key, st] of Array.from(fractalState.entries())){
    if (!newKeys.has(key)) {
      st.targetScale.set(0,0,0);
      if (st.dotMesh) st.dotMesh.scale.set(0,0,0);
      if (st.labelSprite) { scene.remove(st.labelSprite); st.labelSprite=null; }
    }
  }
  for (const key of newKeys){
    const t = targetState.get(key); const ex = fractalState.get(key);
    const isImg = imageCells.has(key); const isBtn = buttonCells.has(key);
    let material = darkMaterial;
    if (isImg) {
      const idx = imageAssignment.get(key); const url = imageTextures[idx];
      material = getImageMaterial(url);
    }
    if (ex){
      ex.targetPosition.set(t.x, t.y, 0); ex.targetScale.set(t.size, t.size, 1);
      if (ex.mesh.material !== material) ex.mesh.material = material;
      if (ex.labelSprite && !isBtn) { scene.remove(ex.labelSprite); ex.labelSprite=null; }
      if (isBtn) {
        const label = buttonCells.get(key)?.label || '';
        if (!ex.labelSprite) {
          const spr = makeTopRightLabelSprite(label, t.size);
          const m = t.size*0.03; spr.position.set(t.x + t.size/2 - m, t.y + t.size/2 - m, 0.2);
          ex.labelSprite=spr; scene.add(spr);
        } else {
          const m = ex.targetScale.x*0.03; ex.labelSprite.position.set(t.x + t.size/2 - m, t.y + t.size/2 - m, 0.2);
          ex.labelSprite.scale.set(ex.targetScale.x, ex.targetScale.x*0.75, 1);
        }
      }
      ex.isButton=isBtn; ex.isImage=isImg;
    } else {
      const mesh = meshPool.pop() || new THREE.Mesh(geometry);
      mesh.material = material; mesh.position.set(t.x,t.y,0); mesh.scale.set(0,0,0); mesh.renderOrder = 0; scene.add(mesh);
      const st = { mesh, dotMesh:null, labelSprite:null, targetPosition:new THREE.Vector3(t.x,t.y,0), targetScale:new THREE.Vector3(t.size,t.size,1), originalSize:t.originalSize, isButton:isBtn, isImage:isImg, hover:false };
      fractalState.set(key, st);
      if (!isImg && config.showDots) addDotToState(st);
      if (isBtn) {
        const label = buttonCells.get(key)?.label || '';
        const spr = makeTopRightLabelSprite(label, t.size);
        const m = t.size*0.03; spr.position.set(t.x + t.size/2 - m, t.y + t.size/2 - m, 0.2);
        st.labelSprite = spr; scene.add(spr);
      }
    }
  }
}
function getDotScale(state){
  const cappedDotSize = Math.min(0.5, config.dotSize);
  if (config.dotSizeIsRelative) return state.mesh.scale.x * cappedDotSize;
  const viewHeight = camera.top - camera.bottom; const viewWidth = camera.right - camera.left; const gridSize = Math.max(viewWidth, viewHeight); const baseSize = gridSize / 256; return baseSize * cappedDotSize;
}
function addDotToState(st){ if (st.dotMesh) return; st.dotMesh = dotMeshPool.pop() || new THREE.Mesh(geometry, dotMaterial); st.dotMesh.position.copy(st.mesh.position); st.dotMesh.renderOrder = 0; scene.add(st.dotMesh); const sc = getDotScale(st); st.dotMesh.scale.set(sc, sc, 1); }

/* Anim */
function animate(){
  requestAnimationFrame(animate);
  if (needsBaseUpdate){ 
    const ok = updateFractalBase(false);
    if (ok) { syncStateToMeshes(); }
    needsBaseUpdate=false;
  }
  if (needsRefineCheck){
    const wp = new THREE.Vector3(lastMouseScreenPos.x, lastMouseScreenPos.y, 0).unproject(camera);
    if (refineTargetStateAt(wp)) syncStateToMeshes();
    updateMouseSquareTarget(wp); needsRefineCheck=false;
  }

  mouseSquare.position.lerp(mouseSquare.userData.targetPosition, config.mouseSquareAnimationSpeed);
  mouseSquare.scale.lerp(mouseSquare.userData.targetScale, config.mouseSquareAnimationSpeed);
  cursorBorder.position.lerp(cursorBorder.userData.targetPosition, config.mouseSquareAnimationSpeed);
  cursorBorder.scale.lerp(cursorBorder.userData.targetScale, config.mouseSquareAnimationSpeed);

  let hoverAny=false;
  for (const [key, st] of Array.from(fractalState.entries())){
    if (st.isButton) {
      st.mesh.position.copy(st.targetPosition); st.mesh.scale.copy(st.targetScale);
      if (st.labelSprite){
        const m = st.targetScale.x * 0.03;
        st.labelSprite.position.set(st.targetPosition.x + (st.targetScale.x/2 - m), st.targetPosition.y + (st.targetScale.x/2 - m), 0.2);
        st.labelSprite.scale.set(st.targetScale.x, st.targetScale.x*0.75, 1);
      }
    } else {
      st.mesh.position.lerp(st.targetPosition, config.gridAnimationSpeed);
      st.mesh.scale.lerp(st.targetScale, config.gridAnimationSpeed);
    }

    if (st.isButton && st.labelSprite){
      const wp = new THREE.Vector3(lastMouseScreenPos.x, lastMouseScreenPos.y, 0).unproject(camera);
      const half = st.targetScale.x/2;
      const inside = (wp.x>=st.targetPosition.x-half && wp.x<=st.targetPosition.x+half && wp.y>=st.targetPosition.y-half && wp.y<=st.targetPosition.y+half);
      if (inside){ st.labelSprite.material.color.set(COLORS.accent); hoverAny=true; }
      else       { st.labelSprite.material.color.setStyle(COLORS.textCSS); }
    }

    if (st.dotMesh){ st.dotMesh.position.copy(st.mesh.position); if (st.isImage && st.dotMesh.scale.x>0) st.dotMesh.scale.set(0,0,0); }

    if (st.mesh.scale.x < 0.001 && st.targetScale.x===0){
      scene.remove(st.mesh); meshPool.push(st.mesh);
      if (st.dotMesh){ scene.remove(st.dotMesh); dotMeshPool.push(st.dotMesh); }
      if (st.labelSprite){ scene.remove(st.labelSprite); }
      fractalState.delete(key);
    }
  }
  document.body.style.cursor = hoverAny ? 'pointer' : 'default';

  renderer.render(scene, camera);
  const canvas = document.getElementById('webgl-canvas');
  if (canvas && canvas.style.opacity!=='1') canvas.style.opacity='1';
}

function findLeafAt(worldPos, stateMap){
  let best=null, smallest=Infinity;
  for (const sq of stateMap.values()){
    const half = sq.originalSize/2;
    const inside = worldPos.x>=sq.x-half && worldPos.x<=sq.x+half && worldPos.y>=sq.y-half && worldPos.y<=sq.y+half;
    if (inside && sq.originalSize<smallest){ best=sq; smallest=sq.originalSize; }
  }
  return best;
}
function refineTargetStateAt(worldPos){
  let refined=false, it=0;
  while (it<refineBudgetPerFrame){
    it++;
    const leaf = findLeafAt(worldPos, targetState); if (!leaf) break;
    if (imageCells.has(leaf.path) || buttonCells.has(leaf.path)) break;
    if (leaf.depth < TARGET_DEPTH){
      refined=true; targetState.delete(leaf.path);
      const {x,y, originalSize:os, depth:d, path:p} = leaf; const ns=os/2, nd=d+1, o=os/4;
      createQuadTree(x-o, y+o, ns, nd, p+'/0', -1);
      createQuadTree(x+o, y+o, ns, nd, p+'/1', -1);
      createQuadTree(x-o, y-o, ns, nd, p+'/2', -1);
      createQuadTree(x+o, y-o, ns, nd, p+'/3', -1);
    } else break;
  }
  return refined;
}
function updateMouseSquareTarget(worldPos){
  const leaf = findLeafAt(worldPos, targetState); if (!leaf) return;
  const dd = Math.max(0, TARGET_DEPTH - leaf.depth); const cell = leaf.originalSize / Math.pow(2, dd);
  const lx = worldPos.x - (leaf.x - leaf.originalSize/2); const ly = worldPos.y - (leaf.y - leaf.originalSize/2);
  const ix = Math.max(0, Math.min(Math.floor(lx / cell), Math.pow(2, dd)-1)); const iy = Math.max(0, Math.min(Math.floor(ly / cell), Math.pow(2, dd)-1));
  const nx = (leaf.x - leaf.originalSize/2) + ix*cell + cell/2; const ny = (leaf.y - leaf.originalSize/2) + iy*cell + cell/2; const fs = Math.max(0, cell - config.borderWidth);
  mouseSquare.userData.targetPosition.set(nx,ny,4); mouseSquare.userData.targetScale.set(fs,fs,1);
  cursorBorder.userData.targetPosition.set(nx,ny,3); cursorBorder.userData.targetScale.set(fs+config.borderWidth, fs+config.borderWidth, 1);
}

/* Mouse & Click */
function onMouseMove(e){
  lastMouseScreenPos.set((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
  needsRefineCheck = true;
}
function onClick(){
  const wp = new THREE.Vector3(lastMouseScreenPos.x,lastMouseScreenPos.y,0).unproject(camera);
  for (const [key, st] of fractalState.entries()){
    if (!st.isButton) continue;
    const half = st.targetScale.x/2;
    const inside = (wp.x>=st.targetPosition.x-half && wp.x<=st.targetPosition.x+half && wp.y>=st.targetPosition.y-half && wp.y<=st.targetPosition.y+half);
    if (inside && buttonCells.has(key)){ const {url}=buttonCells.get(key); window.location.href = url; return; }
  }
  // clic ailleurs => nouveau layout aléatoire
  resetFractalRandom();
}

</script>
</body>
</html>
